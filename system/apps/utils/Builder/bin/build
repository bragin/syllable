#! ruby

# Syllable Build System
# Version 0.3.18
# Copyright (c) 2002-2004 Kaj de Vos
# License: GPL 2


# Set environment variables

ENV['CFLAGS']	= "-march=i586 -O2 -pipe"
ENV['CXXFLAGS']	= "-march=i586 -O2 -pipe"

# Define paths

@workDir		= Dir.getwd

@builderPath	= "/Applications/Builder"
@profilesPath	= File.join @builderPath, "profiles"
@sourcesPath	= File.join @builderPath, "sources"
@packagesPath	= File.join @builderPath, "packages"
@logsPath		= File.join @builderPath, "logs"

# Define settings

# Include version number on installed packages?
@includeVersion = false
#@includeVersion = true

unless @systemBuild = File.basename(@workDir) == "system"
	@installRoot = "/usr"
else
	@distroRoot = File.join @workDir, "dist-root"
#	@buildTools = File.join @workDir, "build-tools"

	@installRoot = File.join(@distroRoot, "atheos/usr")

	ENV['DIST_VER']  = "0.5.2+"
	ENV['DIST_NAME'] = "base-syllable-0.5.2+.tgz"

	ENV['ATHEOS_SRC']			= @workDir
	ENV['ATHEOS_INCLUDE_PATH']	= File.join @workDir, "sys/include"
	ENV['ATHEOS_LIB_PATH']		= File.join @workDir, "libs"
	ENV['BUILD_TOOLS']			= File.join @workDir, "build-tools"
	ENV['DIST_DIR']				= @distroRoot
end


# Functions for single packages

def unpackPackage target
	Dir.chdir File.dirname(target) if target["/"]

	base = File.join @sourcesPath, ((pack = recipe(target)["packages"]) ?
		pack :
		fullName(target)
	)
#	file = Dir[File.join(@sourcesPath, fullName target) + ".*"] [0]
#	case File.basename file
	unless
		if exists? file = base + ".tar.bz2" or exists? file = base + ".tbz2"
			action "bzcat #{file} | tar x"
		elsif exists? file = base + ".tar.gz" or exists? file = base + ".tgz"
			action "tar xzf " + file
		else
			logError "Source package #{base}.* not found"
			false
		end
	then
		false
	else
		if exists? dir = fullName(target)
			true
		else  # Tarball content has a deviating name
			logSubheader "Moving source"

			unless result = (action "tar tzf " + file)  # Bzip to be implemented
				false
			else
				action "mv #{File.dirname result.split[0]} " + dir
			end
		end
	end
end

def patchPackage target
	if exists? dir = patchesPath(target)
		logHeader "Patching source"
		return false unless action "cp -a #{File.join dir, "*"} ."
	end

	if dirs = (recipe = recipe target)["patch-config"]
		logHeader "Patching configuration"
		files = File.join @sourcesPath, "config/config.*"

		if dirs == ""
			action "cp -a #{files} ."
		else
			for dir in toList dirs
				action "cp -a #{files} #{dir}/"
			end
		end
	elsif dir = recipe["patch-legacy-config"]
		logHeader "Patching configuration"
		action "cp -a #{File.join @sourcesPath, "config/legacy/*"} " +
			(dir == "" ? "." : dir)
	else
		true
	end
end

def getPackage target
	unless
		unless exists? target
			logHeader "Installing source"

			unless exists? dir = File.dirname(target) or action "mkdir --parents " + dir
				false
			else  # We have a destination dir
				unless unpackPackage target
					false
				else
					Dir.chdir @workDir
					Dir.chdir target

					patchPackage target
				end
			end
		else
			unless exists? File.join(target, "CVS")
				# Source already prepared
				true
			else
				if Dir[File.join(@sourcesPath, fullName(target) + ".t*")] != []  # Some tarball
					puts "\nWARNING! This will clobber your CVS repository!"
					logHeader "Replacing source"

					unless action "rm -r " + target
						logError "Failed to delete source"
						false
					else
						unless unpackPackage target
							false
						else
							Dir.chdir @workDir
							Dir.chdir target

							patchPackage target
						end
					end
				else
					Dir.chdir target
					unless thirdParty?
						true
					else
						puts "\nWARNING! This will clobber your CVS repository!"
						deleteCVSData
						patchPackage target
					end
				end
			end
		end
	then
		logError "Source not installed"
		logFailure target
		false
	else
		action "sync"
	end
end

def configurePackage target
	unless thirdParty?
		logHeader "Building dependencies"
		action "make deps"

		true  # Continue building even if dependencies failed
	else
		unless exists? cmd = (cmd = (recipe = recipe(package = fullName(target)))["configure-cmd"]) ? cmd : "configure"
			true
		else
			logHeader "Configuring"
			action "rm config.cache" if exists? "config.cache"
			name = shortName package
			if action (cmdLine = recipe["configure"]) ? toString(cmdLine) :
				((vars = recipe["configure-vars"]) ? vars + " " : "") +
				"./" + cmd +
#				(name == "man" || name == "grub" ? "" :
				((args = recipe["configure-args"]) ?
					" " + args :
					" --prefix=" + prefix(package)
				) +
				((options = recipe["configure-options"]) ? " " + toString(options) : "")
			then true
			else
				logFailure target
				false
			end
		end
	end
end

def cleanPackage target
	unless action "make clean"
#		logFailure target
		false
	else
		action "sync"
	end
end

def makePackage target
	unless action ((vars = recipe(target)["make-vars"]) ? vars + " " : "") +
		"make"
	then
		logFailure target
		false
	else
		action "sync"
	end
end

def testPackage target
	unless action "make " + (targets = recipe(target)["test-targets"]) ? targets : "check"
		logFailure target
		false
	else
		action "sync"
	end
end

def installPackage target
	unless
		if target =~ /.*\.tgz$/ and exists? target  # A distribution package
			if exists? dir = installPath(target) and not
				begin
					logHeader "Uninstalling " + shortName(target)
					uninstallPackage target  # Double failure logging!
				end
			then
				false
			else
				action "tar -C /usr -xpzf " + target and
				begin
					logHeader "Registering " + target
					action "pkgmanager -a " + dir
				end
			end
		else
			begin
				Dir.chdir target
	
				unless thirdParty?
					action "make install"
				else
					if exists? root = installPath(target) and not
						begin
							logHeader "Uninstalling " + shortName(target)
							uninstallPackage target  # Double failure logging!
						end
					then
						false
					else
						if dirs = (recipe = recipe target)["install-tree"]
							logHeader "Creating subdirectories"
							logDetail root
							Dir.mkdir root

							for dir in toList dirs
								logDetail d = File.join(root, dir)
								Dir.mkdir d
							end
						end

						if not action (cmdLine = (recipe = recipe target)["install"]) ? toString(cmdLine) :
							"make" +
							(	(arg = recipe["install-prefix"]) ? " " + arg + root :
								@systemBuild ? " prefix=" + root :
								""
							) +
							" install"
#							" install-strip"
						then
							false
						elsif files = recipe["documentation"] and not
							begin
								logHeader "Installing documentation"
								action "cp -a #{toString files} " + root
							end
						then
							false
						elsif exists? filesPath = File.join(@packagesPath, fullName(target), "distro") and not
							begin
								logHeader "Installing extra files"
								action "cp -a #{File.join filesPath, "*"} " + root
							end
						then
							false
						else
							@systemBuild or
							begin
								logHeader "Registering " + target
								action "pkgmanager -a " + root
							end
						end
					end
				end
			end
		end
	then
		logFailure target
	else
		action "sync"
	end
end

def uninstallPackage target
	unless
		unless target =~ /.*\.tgz$/ and exists? target or  # A distribution package
			thirdParty?
		then
			action "make uninstall"
		else
			dir = installPath target
			name = shortName target

			unless @systemBuild or
				begin
					logHeader "Unregistering " + name
					action "pkgmanager -r " + dir
				end
			then
				false
			else
				logHeader "Deleting " + name
				action "rm -r " + dir
			end
		end
	then
		logFailure target
		false
	else
		action "sync"
	end
end

def makeDistroPackage target  # Should only be called if it's a system build
	if thirdParty?
		installPackage target
	else
		unless
			unless action "make dist"
				false
			else
#				logHeader "Installing documentation"
#				if action "make doc"
#					action "make install-doc"
#				end

				true
			end
		then
			logFailure target
		else
			action "sync"
		end
	end
end

def buildPackage target
	if getPackage target  # Source is available
		Dir.chdir @workDir
		Dir.chdir target

		logHeader "Cleaning"
		cleanPackage target

		if configurePackage target  # No failed configuration
			# Build the directory
			logHeader "Making"
			makePackage target
		end
	end

	Dir.chdir @workDir
end


# Functions for multiple packages

def doPackages command, target
	# Visit all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		action command
		Dir.chdir @workDir
	end
end

def prepare
	if @systemBuild
		logHeader "Building distribution tree"

		if exists? @distroRoot
			action "rm -r " + File.join(@distroRoot, "*")
		else
			Dir.mkdir @distroRoot
		end
		Dir.chdir @distroRoot

#		action File.join(@buildTools, "mkbase.sh") + " " + @distroRoot
		for dir in load File.join(@builderPath, "distro-tree")
			logDetail dir
			Dir.mkdir dir unless exists? dir
		end

		Dir.chdir @workDir
		action "sync"
	end
end

def patch target
	logHeader "Patching " + target

	# Patch all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		unless patchPackage package
			logError "Source not patched"
			logFailure target
		end
		Dir.chdir @workDir
	end
end

def get target
	logHeader "Fetching " + target

	# Fetch all directories

	for package in profile target
		logEntry package
		getPackage package
	end
end

def distclean target
	logHeader "Cleaning distribution " + target
	doPackages "make distclean", target
end

def configure target
	logHeader "Configuring " + target

	# Configure all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		configurePackage package
		Dir.chdir @workDir
	end
end

def clean target
	logHeader "Cleaning " + target

	# Clean all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		cleanPackage package
		Dir.chdir @workDir
	end
end

def make target
	logHeader "Making " + target

	# Make all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		makePackage package
		Dir.chdir @workDir
	end
end

def test target
	logHeader "Testing " + target

	# Test all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		testPackage package
		Dir.chdir @workDir
	end
end

def install target
	logHeader "Installing " + target

	# Install all directories or distribution packages

	for package in profile target
		logEntry package

		installPackage package
		Dir.chdir @workDir
	end
end

def uninstall target
	logHeader "Uninstalling " + target

	# Uninstall all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		uninstallPackage package
		Dir.chdir @workDir
	end
end

def makeDistro target
	logHeader "Making distribution " + target

	profile = profile(target)
	if @systemBuild
		# Visit all directories

		for package in profile
			logEntry package
			Dir.chdir package
			makeDistroPackage package
			Dir.chdir @workDir
		end
	else  # Create a single package
		file = (name = fullName target) + ".bin.1"

		if  # Tar it up
			if action "tar cvf #{file}.tar" +
				" -C #{@installRoot} " +
				(profile.collect {|package| installName package}).join(" ") +
				(files = recipe(target)["distro-files"] ? " " + files : "")
			then
				if profile.is_a? Array and exists? distroDir = File.join(@packagesPath, name, "distro")
					# It's a compound package; add extra files
					Dir.chdir distroDir
					action "tar rvf #{File.join @workDir, file}.tar *"
					Dir.chdir @workDir
				else
					true
				end
			end
		then
			# Zip it up
			if action "gzip #{file}.tar"
				action "mv #{file}.tar.gz #{file}.tgz"
			end
		end
	end
end

def build target
	logHeader "Building " + target

	# Build all directories

	for package in profile target
		logEntry package
		buildPackage package
	end
end


# Helper functions

def deleteCVSData
	# Delete all CVS dirs
	# (They would trigger some packages to reconfigure themselves.)

	logHeader "Cleaning out CVS dirs"

	Dir["**/CVS"].each do |dir|
		logDetail dir

		# Delete all files in the CVS dir first
		Dir.foreach dir do |file|
			f = File.join dir, file
			File.delete f if File.stat(f).file?
		end

		Dir.delete dir
	end
end

def exists? file
	FileTest.exists? file
end

def load file  # Load the lines of a file into an array, leaving out comments
	lines = []

	File.open file do |file|
		file.each do |line|
			# Get rid of record delimiter and comments
			lines += [line.chomp] unless line =~ /^\s*;/
		end
	end

	lines
end

def save data, file  # Write an array to a text file
	File.open file, "w" do |file|
		for line in data
			file << line + "\n"
		end
	end
end

def parseValues text  # Load key/value pairs into a hash table
	hash = {}

	for line in text
		if line !~ /^\s+/  # A key line
			unless i = line.index(/\s/)  # A single key
				hash[lastKey = line] = ""
			else  # A key with a single value
				hash[line[0, i]] = line[i + 1 .. line.length - 1].strip
			end
		else  # Starts with whitespace, so it's a list value
			if hash[lastKey] == ""
				hash[lastKey] = [line.strip]
#				margin = $&
			else
				hash[lastKey] << line.strip
			end
		end
	end

	hash
end

def toList value  # Normalize value into an array
	if value.is_a? String
		if value == ""
			[]
		else
			[value]
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def toString value  # Join list value into a space-separated string
	if value.is_a? Array
		value.join(" ")
	else  # Assume it's already a string, or nil
		value
	end
end

def thirdParty?
	exists? ((cmd = recipe(dir = Dir.getwd)["configure-cmd"]) ? cmd : "configure") or
		shortName(dir) == "bzip2"
# Currently conflicts with Ffmpeg:
#		exists? File.join(@packagesPath, package = fullName(Dir.getwd), package + ".recipe")
end

def fullName package
	# Extract name including version, if necessary
	File.basename package[-1, 1] == "/" ? package.chop : package
end

def shortName package
	# Extract name without version
	/(-\d)|$/.match(fullName(package)).pre_match
end

def installName package
	package = fullName package
	@includeVersion && ! @systemBuild ?
		package :
		shortName(package)
end

def prefix package
	File.join "/usr", installName(package)
end

def installPath package
	File.join @installRoot, installName(package)
end

def patchesPath package
	File.join @packagesPath, fullName(package), "patches"
end

def profile target  # Return the list of packages for the build target
	if target["/"]  # A single directory
		target[-1, 1] == "/" ? target.chop : target
	elsif exists? file = File.join(@profilesPath, target)  # A profile
		load file
	else
		target
	end
end

def recipe package  # Load the key/value pairs of a recipe into a hash table
	package = fullName package
	if exists? recipe = File.join(@packagesPath, package, package + ".recipe")
		parseValues load(recipe)
	else
		{}
	end
end

def action command  # Return the output of the shell command, or false if unsuccessful
	logAction command
	stdout = `#{command}`
	if (status = $? >> 8) == 0  # OK
		logResult stdout
		stdout
	else
		logError status
		logResult stdout
		false
	end
end

def openLogs
	@failures = []

	Dir.mkdir @logsPath unless exists? @logsPath

	@log		= File.new File.join(@logsPath, "last-stdout"), "w"
	@summary	= File.new File.join(@logsPath, "last-summary"), "w"
	@failLog	= File.new File.join(@logsPath, "last-failures"), "w"

	@log		<< s = "Building in root directory #{@workDir}\n"
	@summary	<< s
	@failLog	<< s
end

def closeLogs
	@log		<< s = "\nFinished\n"
	@summary	<< s

	@log.close
	@summary.close
	@failLog.close
end

def logHeader header
	print		"\n" + s = header + "\n"
	@log		<< "\n#{s}\n"
	@summary	<< s
end

def logSubheader header
	print		"\n" + s = header + "\n"
	@log		<< "\n" + s
	@summary	<< s
end

def logEntry entry
	print		s = "\n#{entry}\n"
	@log		<< s
	@summary	<< s
end

def logDetail detail
	puts		detail
	@log		<< detail + "\n"
end

def logAction action
	puts		"\n#{action}\n"
	@log		<< action + ": "
	@summary	<< action
end

def logError error
	puts		"\n" + s = "Error: #{error}"
	@log		<< s + ":"
	@summary	<< ": " + s
end

def logResult result
	@log		<< "\n\n" << result
	@summary	<< "\n"
end

def logFailure target
	@failLog	<< target + "\n"
	@failures	<< target
end


# Main function

arg1, arg2 = ARGV[0], ARGV[1]

case arg1
when "-v", "--version"
	puts "Syllable Build System 0.3.18",
		"Copyright (c) 2002-2004 Kaj de Vos",
		"License: GPL 2"
when "?", "-?", "-h", "-help", "--help"
	puts "Usage: build [<command>] [<package> | <profile> | <distribution> | <log>]",
		"<command>:",
		"  -h, --help,   Show this help information",
		"    -help, ?, -?",
		"  -v, --version Show version information",
		"  prepare       Initialize system distribution tree",
		"  get           Fetch and patch sources",
		"  patch         Patch sources",
		"  distclean",
		"  clean",
		"  configure",
		"  make",
		"  test",
		"  install       (Run as super-user)",
		"  uninstall     (Run as super-user)",
		"  distro        Build a distribution package or a system distribution",
		"  list          List a profile",
		"  log           Show the last log",
		"<package>:      Package subdirectory",
		"<profile>:      Profile name",
		"  last          Last used profile",
		"  failures      Profile for last failures",
		"<distribution>: Distribution package ((un)install command only)",
		"<log>:          Log name",
		"  summary       Summarized log",
		"  failures      Log of failed packages"
when "list" then print IO.readlines(File.join(@profilesPath, arg2))
when "log"  then print IO.readlines(File.join(@logsPath, arg2 ? "last-" + arg2 : "last-stdout"))
else
	openLogs

	if arg1 == "prepare"
		prepare
	else
		profile = profile target = arg2 ? arg2 : arg1 ? arg1 : "default"

		if profile.is_a? Array  # Not a single package
			save profile, File.join(@profilesPath, "last")
		end

		if @systemBuild
			File.delete "/ainc" if exists? "/ainc"
			action "ln -s #{File.join @workDir, "sys/include"} /ainc"

			prepare unless exists? @distroRoot
		end

		case arg1
		when "get"			then get arg2
		when "patch"		then patch arg2
		when "distclean"	then distclean arg2
		when "clean"		then clean arg2
		when "configure"	then configure arg2
		when "make"			then make arg2
		when "test"			then test arg2
		when "install"		then install arg2
		when "uninstall"	then uninstall arg2
		when "distro"		then makeDistro arg2
		else
			if arg2
				logError "Unrecognized command"
				exit
			else
				build target
			end
		end

		if profile.is_a? Array  # Not a single package
			save @failures, File.join(@profilesPath, "failures")
		end

		if @systemBuild
			File.delete "/ainc"
			action "ln -s /system/include /ainc"
		end

		action "sync"
	end

	closeLogs
end
