#!/usr/bin/env ruby

# Syllable Build System
# Version 0.6.24
# Copyright (c) 2002-2005 Kaj de Vos
# License: GPL 2


# Functions for single modules

def prepare target
	@log.header 'Creating staging area'

	if exists? @stage
		@log.header 'Deleting old staging area'
		action 'rm -r ' + File.join(@stage, '*')
	else
		Dir.mkdir @stage
	end

	Dir.mkdir File.join(@stage, 'etc')
	Dir.mkdir File.join(@stage, 'bin')
	Dir.mkdir File.join(@stage, 'sbin')
	Dir.mkdir File.join(@stage, 'include')
	Dir.mkdir File.join(@stage, 'lib')
	Dir.mkdir File.join(@stage, 'libexec')
	Dir.mkdir File.join(@stage, 'man')
	Dir.mkdir File.join(@stage, 'info')
	Dir.mkdir File.join(@stage, 'share')
	Dir.mkdir File.join(@stage, 'init')

	if @systemBuild and target.profile and tree = target.profile['tree']
		@log.header 'Building distribution tree'

		Dir.mkdir @systemImage
		Dir.chdir @systemImage

		for line in parseList tree
			dir, icon = line.split
			@log.detail dir
			Dir.mkdir dir unless exists? dir

			if icon
				@log.detail 'Setting icon ' + icon
				action "addattrib #{dir} os::Icon " + File.join(@iconsPath, icon)
			end
		end

		Dir.chdir @workDir
	end

	action 'sync'
end

def downloadModule target
	unless
		(exists? dir = File.dirname(target) or action 'mkdir --parents ' + dir) and
		begin  # We have a destination dir
			Dir.chdir File.dirname(target)  # if target['/']

			@log.subheader 'Checking out sources from CVS repository'
			action "cvs -q checkout -d #{File.basename target} " + File.join(@cvsPath, target)
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def updateModule target
	unless
		unless exists? target
			@log.error 'Source not installed; unable to update'
			false
		else
			Dir.chdir target
#			if exists? 'CVS'

			@log.subheader 'Updating sources from CVS repository'
			action 'cvs -q update -dP'
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def unpackModule target
	unless
		unless exists? dir = File.dirname(target) or action 'mkdir --parents ' + dir
			false
		else  # We have a destination dir
			Dir.chdir File.dirname(target)  # if target['/']
		
			files = []
		
			unless
				for package in (packages = getRecipe(target)['packages']) ?
					parseList(packages) :
					[fullName(target)]
		
					package, dir = package.split
					base = File.join @sourcesPath, package
					option = dir ? ' --directory=' + dir : ''
		
#					file = Dir[File.join(@sourcesPath, fullName target) + '.*'] [0]
#					case File.basename file
		
					if exists? file = base + '.zip'
						type = :zip
						break unless action 'unzip ' + file + (dir ? ' -d ' + dir : '')
					elsif exists? file = base + '.tar.bz2' or exists? file = base + '.tbz2'
						type = :bzip
						break unless action "bzcat #{file} | tar#{option} -x"
					elsif exists? file = base + '.tar.gz' or exists? file = base + '.tgz'
						type = :gzip
						break unless action "tar#{option} -xzf " + file
					else
						@log.error "Source package #{base}.* not found"
						break
					end
		
					files << [file, type]
					action 'sync'
				end
			then
				false
			else
				if exists? dir = fullName(target)
					true
				else  # Source package content has a deviating subdirectory name
					@log.subheader 'Renaming source'
		
					file, type = files.first
					result = `#{case type
						when :zip  then 'unzip -lqq ' + file
						when :bzip then "bzcat #{file} | tar --list"
						when :gzip then 'tar tzf ' + file
						end
					}`
					unless (status = $? >> 8) == 0
						@log.error status
						false
					else  # Get the directory name from the package listing
						action "mv #{type == :zip ?
							result.first.split.last :
							result.split("/").first
						} " + dir
					end
				end
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def patchModule target
	if parent = (recipe = getRecipe(target))['inherits']
		if exists? file = File.join(recipePath(parent), fullName(parent) + '.patch')
			@log.header 'Applying patch from parent ' + parent
			return false unless action 'patch --strip=1 < ' + file
		end
	
		if exists? dir = patchesPath(parent)
			@log.header 'Overlaying extra source files from parent ' + parent
			return false unless action "cp -a #{File.join dir, '*'} ." and
				# FIXME: crude way to remove possible CVS dirs from patches
				deleteCVSData
		end
	end

	if exists? file = File.join(recipePath(target), fullName(target) + '.patch')
		@log.header 'Applying patch'
		return false unless action 'patch --strip=1 < ' + file
	end

	if exists? dir = patchesPath(target)
		@log.header 'Overlaying extra source files'
		return false unless action "cp -a #{File.join dir, '*'} ." and
			# FIXME: crude way to remove possible CVS dirs from patches
			deleteCVSData
	end

	unless
		if dirs = recipe['patch-config']
			@log.header 'Patching configuration'
			files = File.join @configPath, 'config/config.*'
	
			if dirs == ''
				action "cp -a --force #{files} ."
			else
				for dir in toList dirs
					return false unless action "cp -a --force #{files} #{dir}/"
				end
			end
		elsif dir = recipe['patch-legacy-config']
			@log.header 'Patching configuration'

			action "cp -a #{File.join @configPath, 'config/legacy/*'} " +
				(dir == '' ? '.' : dir)
		else
			true
		end
	then
		false
	else
		if cmdLine = recipe['patch']
			@log.header 'Executing patch instructions'
			action toCommand(cmdLine)
		else
			true
		end
	end
end

def getModule target
	unless
		unless exists? target
			@log.subheader 'Installing source'

			if sourcePackagesAvailable? target
				unpackModule target
			else
				downloadModule target and
				begin
					# FIXME: crude way to remove CVS files
					Dir.chdir @workDir
					Dir.chdir target
					deleteCVSData
				end
			end and
			begin
				Dir.chdir @workDir
				Dir.chdir target
				patchModule target
			end
		else
			unless exists? File.join(target, 'CVS')
				# Source already prepared
				true
			else
				if sourcePackagesAvailable? target
					puts "\nWARNING! If this is a CVS repository, it will be clobbered!"
					@log.subheader 'Replacing source'

					unless action 'rm -r ' + target
						@log.error 'Failed to delete source'
						false
					else
						unless unpackModule target
							false
						else
							Dir.chdir @workDir
							Dir.chdir target
							patchModule target
						end
					end
				else
					native? target or
					begin
						Dir.chdir target
						deleteCVSData
						patchModule target
					end
				end
			end
		end
	then
		# FIXME: cascading error reporting
		@log.error 'Source not (completely) installed'
		@log.failure target
		false
	else
		true
	end
end

def configureModule target
	if native? target
		@log.header 'Building dependencies'

		Dir.chdir target
		action makeCommand(target) + ' deps'
		# Continue building even if dependencies failed
		action 'sync'
	else
		Dir.chdir target

		unless
			if cmdLine = (recipe = getRecipe target)['configure']
				if cmdLine == ''
					@log.header 'Skipping configuring'
				else
					@log.header 'Configuring'
					action toCommand(cmdLine)
				end
			else
				unless exists? cmd = (cmd = recipe['configure-cmd']) ? toString(cmd) : 'configure'
					# Nothing to be done here
					true
				else
					unless noBuildDir = recipe['no-build-dir'] or exists? dir = buildDir(target) or
						begin
							@log.header 'Creating build directory'
							action 'mkdir ' + dir
						end
					then
						false
					else
						@log.header 'Configuring'
	
						# Some ports require an absolute path to the configure command
						cmdPath = File.join(Dir.getwd, File.dirname(cmd))
						Dir.chdir noBuildDir ? File.dirname(cmd) : dir
	
						if exists? 'config.cache' and not action 'rm config.cache'
							false
						else
							if cmdLine = recipe['pre-configure'] and not action toCommand(cmdLine)
								false
							else
								action(((vars = recipe['configure-env']) ? toVariables(vars) + ' ' : '') +
									File.join((noBuildDir ? '.' : cmdPath), File.basename(cmd)) +
									((args = recipe['configure-args']) ?
										' ' + toString(args) :
										((p = recipe['configure-prefix']) ?
											' ' + p :
											' --prefix='
										) + prefix(target) +
										(@crossCompile ? " --build=#{ENV['MACHTYPE']} --host=" + @target : '')
									) +
									((options = recipe['configure-options']) ? ' ' + toString(options) : '')
								)
							end
						end
					end
				end
			end
		then
			@log.failure target
			false
		else
			action 'sync'
		end
	end
end

def cleanModule target
	unless
		if exists? dir = buildDir(target)
			@log.header 'Deleting build directory'
			action 'rm --recursive --force ' + dir
		else
			action makeCommand(target) + ' clean'
		end
	then
#		@log.failure target
		false
	else
		action 'sync'
	end
end

def makeModule target
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless
		if (cmdLine = (recipe = getRecipe(target))['pre-make']) and not action toCommand(cmdLine)
			false
		else
			unless action(
				((vars = recipe['make-env']) ? toVariables(vars) + ' ' : '') +
				makeCommand(target) +
				((vars = recipe['make-vars']) ? ' ' + toVariables(vars) : '') +
				((options = recipe['make-options']) ? ' ' + toString(options) : '') +
				((targets = recipe['make-targets']) ? ' ' + toString(targets) : '')
			)
				false
			else
				not (cmdLine = recipe['post-make']) or action toCommand(cmdLine)
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def testModule target
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless action makeCommand(target) + ' ' +
		((options = (recipe = getRecipe(target))['test-options']) ? toString(options) + ' ' : '') +
		((targets = recipe['test-targets']) ? toString(targets) : 'check')
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def installModule staging, target
	unless
		if target =~ /\.(zip|tgz)$/ and exists? target  # A distribution package
			# Packages are currently supposed to contain an unversioned directory
			root = File.join(File.dirname(installPath(false, target)), shortName(target))

			if exists? root and not
				begin
					@log.header 'Uninstalling ' + shortName(target)
					uninstallModule false, target  # FIXME: double failure logging!
				end
			then
				false
			else
				@log.header 'Unpacking ' + target
				action (target[-3..-1] == 'zip' ?
					"unzip '#{target}' -d /usr" :
					"tar --directory=/usr -xpPzf '#{target}'"
				) and
				begin
					@log.header 'Registering ' + target
					action 'pkgmanager --add ' + root
				end
			end
		else
			if native? target
				Dir.chdir target
				if exists? dir = buildDir(target) then Dir.chdir dir end

				unless staging
					action makeCommand(target) + ' install'
				else
					unless action makeCommand(target) + ' dist'
						false
					else
#						@log.header 'Installing documentation'
#						if action makeCommand(target) + ' doc'
#							action makeCommand(target) + ' install-doc'
#						end

						true
					end
				end
			else
				root = installPath staging, target

				if exists? root and not
					begin
						@log.header 'Uninstalling ' + shortName(target)
						uninstallModule staging, target  # FIXME: double failure logging!
					end
				then
					false
				else
					if dirs = (recipe = getRecipe target)['install-tree']
						@log.header 'Creating subdirectories'
						@log.detail root
						Dir.mkdir root

						for dir in toList dirs
							@log.detail d = File.join(root, dir)
							Dir.mkdir d
						end
					end

					unless exists? target
						true
					else
						Dir.chdir target
						if exists? dir = buildDir(target) then Dir.chdir dir end
	
						if not action(
							if cmdLine = recipe['install']
								toCommand cmdLine
							else
								((vars = recipe['install-env']) ? toVariables(vars) + ' ' : '') +
								makeCommand(target) +
								( (var = recipe['install-prefix-var']) ? " #{var}=" + root :
									staging ? ' prefix=' + root :
									''
								) +
								((vars = recipe['install-vars']) ? ' ' + toVariables(vars) : '') +
								' ' + ((targets = recipe['install-targets']) ? toString(targets) : 'install')
							end
						)
							false
						elsif files = recipe['install-files'] and not
							begin
								@log.header 'Installing files'
	
								for line in parseList files
									source, destination = toList line
									break unless action "cp -a #{source} " + File.join(root, destination)
								end
							end
						then
							false
						else
							not files = recipe['documentation'] or
							begin
								@log.header 'Installing documentation'
								Dir.chdir @workDir
								Dir.chdir target
								action "cp -a #{toString files} " + root
							end
						end
					end and
					if exists? filesPath = File.join(@portsPath, fullName(target), 'distro') and not
						begin
							@log.header 'Installing extra files'
							action "cp -a #{File.join filesPath, '*'} " + root and
							begin
								# FIXME: crude way to remove possible CVS dirs from files
								Dir.chdir root
								deleteCVSData
							end
						end
					then
						false
					elsif links = recipe['links'] and links != '' and not
						begin
							@log.header 'Creating links'

							for link in parseList links
								original, destination = toList link
								linkPath = File.dirname destination
								linkFile = File.basename destination

								if linkPath[0, 1] == '/'  # A link into the system
									original = File.join prefix(target), original if original['/']

									if staging and @systemBuild
										linkPath = File.join @systemRoot,
											linkPath[0, 4] == '/usr' ?
												'' :
												'sys',  # A link into the core system
											linkPath
									end
								else  # A link within the package
									linkPath = File.join root, linkPath
								end

								break unless action "cd #{linkPath} && ln -sf #{original} " + linkFile
							end
						end
					then
						false
					elsif files = recipe['system-libs'] and not
						begin
							@log.header 'Moving system libraries'

							for libs in toList files
								break unless action "mv #{File.join(root, 'lib', libs)} " +
									(staging && @systemBuild ?
										File.join(@systemRoot, 'sys/libs/') :
										'/system/libs/'
									)
							end
						end
					then
						false
					else
						@log.header 'Registering ' + target

						if staging
							registerPort staging, target and (  # @systemBuild or (
								not exists? dir = File.join(root, 'init') or
								for file in listFiles dir
									# FIXME: break unless action 'source ' + file
								end
							)  # )
						else
							action 'pkgmanager --add ' + root
						end
					end
				end
			end
		end
	then
		@log.failure target
	else
		action 'sync'
	end
end

def uninstallModule staging, target
	unless
		if dir? target and native? target
		then  # A native module
			Dir.chdir target
			if exists? dir = buildDir(target) then Dir.chdir dir end

			action makeCommand(target) + ' uninstall'
		else
			dir = installPath staging, target
			name = shortName target

			unless staging or
				begin
					@log.header 'Unregistering ' + name
					action 'pkgmanager --remove ' + dir
				end
			then
				false
			else
				@log.header 'Deleting ' + name
				action 'rm --recursive --force ' + dir
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def buildPackage target
	file = (name = fullName target) + '.bin.1.zip'

	unless
		if exists? file and not action 'rm ' + file
			# Zip would add to the existing package
			@log.error "Couldn't remove existing package " + file
			false
		else
			Dir.chdir root = installRoot(false)

#			action 'tar -cvzf ' + file +
#				" --directory=#{root} " +
			action 'zip -ry' +
#				' -b ' + dereference(root) +  # Doesn't work
				" #{File.join @workDir, file} " +
					installName(name)
#				Doesn't work with Zip:
#				(	(links = (links = parseList(getRecipe(name)['links'])) ?
#						links.collect { |link|
#							(destination = toList(link)[1])[0, 1] == '/' ?  # A link into the system
#								destination :
#								nil
#						}.compact :
#						[]
#					) == [] ?
#						'' :
##						' --absolute-names ' + toString(links)
#						' ' + toString(links)
#				)
		end
	then
		@log.failure target
	else
		action 'sync'
	end
end

def registerPort staging, target  # Create symlinks for a ported package
#	@log.header 'Registering ' + target

	unless
		for subdir in ['etc', 'bin', 'sbin', 'info', 'init']  # Flat directories
			break unless linkSubdir staging, target, subdir, false
		end and
		for subdir in ['lib', 'libexec', 'include', 'share'] << 'man'  # Nested directories
			break unless linkSubdir staging, target, subdir, true
		end
	then
#		@log.failure target
		false
	else
		action 'sync'
	end
end

def linkSubdir staging, target, subdir, nesting
	not exists? dir = File.join(installPath(staging, target), subdir) or
	begin
		@log.detail subdir
		Dir.chdir dir

		Dir[nesting ? '**/*' : '*'].each do |node|
			break unless
				linkNode subdir, node,
					File.join(dir, node),
					File.join(@stage, subdir, node) and
				(staging and not @systemBuild or linkNode subdir, node,
					File.join(installPath(false, target), subdir, node),
					File.join(@indexesRoot, subdir, node)
				)
		end
	end
end

def linkNode subdir, node, source, destination
	if dir? node
		dir? destination or action 'mkdir ' + destination
	elsif symlink? destination
		if subdir == 'info' and node == 'dir'
			@log.warning 'info/dir file not registered due to pre-existing file'
		else
			@log.error "Conflict: link #{destination} already exists!"
			false
		end
	else
		File.symlink source, destination
	end
end

def buildModule staging, target
	if getModule target  # Source is available
		Dir.chdir @workDir  # Target path may be relative or absolute

		@log.header 'Cleaning'
		Dir.chdir target
		cleanModule target
		Dir.chdir @workDir

		if configureModule target  # No failed configuration
			@log.header 'Making'

			if makeModule(target) and staging
				Dir.chdir @workDir

				@log.header 'Installing in staging area'
				installModule true, target
			end
		end
	end

	Dir.chdir @workDir
end


# Functions for multiple modules

def get targets
	@log.header 'Fetching ' + targets.to_s

	for target in targets.modules
		@log.entry target
		getModule target
		Dir.chdir @workDir
	end
end

def download targets
	@log.header 'Downloading ' + targets.to_s

	for target in targets.modules
		@log.entry target
		downloadModule target
		Dir.chdir @workDir
	end
end

def update targets
	@log.header 'Updating ' + targets.to_s

	for target in targets.modules
		@log.entry target
		updateModule target
		Dir.chdir @workDir
	end
end

def unpack targets
	@log.header 'Unpacking ' + targets.to_s

	for target in targets.modules
		@log.entry target
		unpackModule target
		Dir.chdir @workDir
	end
end

def patch targets
	@log.header 'Patching ' + targets.to_s

	for target in targets.modules
		@log.entry target

		Dir.chdir target
		unless patchModule target
			@log.error 'Source not patched'
			@log.failure targets.to_s
		end
		Dir.chdir @workDir
	end
end

def distclean targets
	@log.header 'Cleaning distribution ' + targets.to_s

	for target in targets.modules
		@log.entry target

		Dir.chdir target
		action makeCommand(target) + ' distclean', target
		Dir.chdir @workDir
	end
end

def configure targets
	@log.header 'Configuring ' + targets.to_s

	for target in targets.modules
		@log.entry target

		configureModule target
		Dir.chdir @workDir
	end
end

def clean targets
	@log.header 'Cleaning ' + targets.to_s

	for target in targets.modules
		@log.entry target

		Dir.chdir target
		cleanModule target
		Dir.chdir @workDir
	end
end

def make targets
	@log.header 'Making ' + targets.to_s

	for target in targets.modules
		@log.entry target

		Dir.chdir target
		makeModule target
		Dir.chdir @workDir
	end
end

def test targets
	@log.header 'Testing ' + targets.to_s

	for target in targets.modules
		@log.entry target

		Dir.chdir target
		testModule target
		Dir.chdir @workDir
	end
end

def install targets
	@log.header 'Installing ' + targets.to_s

	for target in targets.modules
		@log.entry target

		installModule false, target
		Dir.chdir @workDir
	end
end

def uninstall targets
	@log.header 'Uninstalling ' + targets.to_s

	for target in targets.modules
		@log.entry target

		uninstallModule false, target
		Dir.chdir @workDir
	end
end

def buildPackages targets
	@log.header 'Making distribution packages ' + targets.to_s

	for target in targets.modules
		@log.entry target

		buildPackage target
		Dir.chdir @workDir
	end
end

def buildPack targets
	@log.header 'Making compound package ' + name = targets.to_s

	unless
		unless (modules = targets.modules).is_a? Array and exists? distroDir = File.join(@portsPath, name, 'distro')
			@log.error 'Not a valid compound package'
			false
		else
			unless action "mkdir " + name
				false
			else
				unless action "cp -a #{File.join distroDir, '*'} " + name
					false
				else
					Dir.chdir name
			
					unless
						deleteCVSData
					then
						false
					else
						Dir.chdir @workDir
			
						unless
							for package in modules
								# Try to find the latest release
								break unless action "ln -s #{Dir[
										File.join(@distrosPath, fullName(package)) + '.bin.*.*z*'
									].last
								} " + name
							end
						then
							false
						else
#							action "tar --dereference --remove-files -cvzf #{name}.bin.1.tgz " + name
							action "zip -rm #{name}.bin.1.zip " + name
#								toString(modules.collect {|package| installName package})
						end
					end
				end
			end
		end
	then
		@log.failure name
	else
		action 'sync'
	end
end

def build staging, targets
	@log.header 'Building ' + targets.to_s

	if staging and @systemBuild and targets.profile and resources = targets.profile['resources']
		@log.header 'Installing resources'

		Dir.chdir @systemImage

		for line in parseList resources
			dir, resource = line.split
			file = File.join @resourcesPath, resource

			unless
				if exists? file
					action "cp -a #{file} " + dir
				else
					action "unzip -o #{file}.zip -d " + dir
				end
			then
				@log.failure targets.to_s
				return
			end
		end

		Dir.chdir @workDir
		action 'sync'
	end

	# Build all directories

	for target in targets.modules
		@log.entry target
		buildModule staging, target
	end
end


# Helper functions

def deleteCVSData
	puts "\nWARNING! If this is a CVS repository, it will be clobbered!"

	# Delete all CVS dirs
	# (They would trigger some ports to reconfigure themselves.)
	@log.header 'Cleaning out CVS directories'

	Dir['**/CVS'].each do |dir|
		@log.detail dir

		# Delete all files in the CVS dir first
		for file in listFiles dir
			File.delete file
		end

		Dir.delete dir
	end

	@log.header 'Cleaning out .cvsignore files'

	Dir['**/.cvsignore'].each do |file|
		@log.detail file
		File.delete file
	end
end

def exists? file
	FileTest.exists? file
end

def file? file
	FileTest.file? file
end

def dir? file
	FileTest.directory? file
end

def symlink? file
	FileTest.symlink? file
end

def listFiles dir
	Dir.entries(dir).collect {|file| File.join dir, file}.delete_if {|file| not file? file}
end

def dereference file
	symlink?(file) ?
		(file[0, 1] == '/' ?
			('/' + dereference(File.readlink(file))) :
			dereference(File.readlink(file))
		) :
		file
end

def loadFile file  # Load the lines of a file into an array, discarding comments and empty lines
	lines = []

	File.open file do |file|
		file.each do |line|
			# Get rid of record delimiter, comments and empty lines
			lines += [line.chomp] unless line.chomp == '' or line[0, 1] == ';'
		end
	end

	lines
end

def saveFile data, file  # Write an array to a text file
	File.open file, 'w' do |file|
		for line in data
			file << line + "\n"
		end
	end
end

def parseDictionary text  # Load key/value pairs into a hash table
	hash = {}

	for line in text
		if line !~ /^\s+/  # A key line
			unless line[/\s/]  # A single key
				hash[lastKey = line] = ''
			else  # A key with a single value
				key, value = splitLine line
				hash[key] = value
			end
		else  # Starts with whitespace, so it's a list value
			if hash[lastKey] == ''
				hash[lastKey] = [line.strip]
#				margin = $&
			else
				hash[lastKey] << line.strip
			end
		end
	end

	hash
end

def parseList value  # Normalize value into an array
	if value.is_a? String
		if value == ''
			[]
		else
			[value]
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def splitLine line
	i = line.index(/\s/)  # First whitespace
	[line[0, i], line[i + 1 .. line.length - 1].strip]
end

def toList value  # Force values into an array
	if value.is_a? String
		if value == ''
			[]
		else
			value.split
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def toString value  # Join list value into a space-separated string
	if value.is_a? Array
		value.join(' ')
	else  # Assume it's already a string, or nil
		value
	end
end

def toCommand value  # Join list value into a semicolon-separated shell command string
	if value.is_a? Array
		value.join(' && ')
	else  # Assume it's already a string, or nil
		value
	end
end

def toVariables value  # Join an array of environment variables into shell syntax
	toString((parseList value).collect do |line|
		var, value = splitLine line
		var + '=' + value
	end)
end

def fullName port
	# Extract name including version, if necessary
	File.basename port[-1, 1] == '/' ? port.chop : port
end

def shortName port
	# Extract name without version
	/(-\d)|$/.match(fullName(port)).pre_match
end

def installName port
	port = fullName port
	@includeVersion && ! @systemBuild ?
		port :
		shortName(port)
end

def prefix port
	File.join '/usr', installName(port)
end

def installRoot staging
	! staging ?
		'/usr' :
	@systemBuild ?
		File.join(@systemRoot, 'usr') :
		@stage
end

def installPath staging, port
	File.join installRoot(staging), installName(port)
end

def recipePath port
	File.join @portsPath, fullName(port)
end

def patchesPath port
	File.join recipePath(port), 'patches'
end

def buildDir target
	'../=' + fullName(target)
end

def native? target
	not exists? File.join(target, 'configure') and not
		# Currently look for a recipe to distinguish from meta-packages:
		exists? File.join(@portsPath, port = fullName(target), port + '.recipe')
end

class Profile
attr_reader :profile

	def Profile.path= path
		@@profilesPath = path
	end

	def initialize target
		@profile = exists?(@file = File.join(@@profilesPath, target)) ?
			parseDictionary(loadFile(@file)) :
			nil
	end

	def [] key
		(value = @profile[key]) ?
			value :
		exists?(file = File.join(@file, key)) ?
			loadFile(file) :
			nil
	end

	def []= key, value
		saveFile [key] + value.collect {|line| "\t" + line}, @file  # File.join(@file, key)
	end
end

def getTarget target
	profile = nil
	Struct.new(:to_s, :modules, :profile).new(
		target,
		# Get the list of modules for the build target, or a single module
		if target['/']  # A single target directory
			target[-1, 1] == '/' ? target.chop : target
		elsif (p = Profile.new target).profile  # A profile
			toList (profile = p)['modules']
		else
			target
		end,
		profile
	)
end

def loadRecipe target  # Read a recipe file
	if exists? file = File.join(recipePath(target = fullName(target)), target + '.recipe')
		loadFile file
	else  # No recipe
		[]
	end
end

def overlayRecipe recipe, overlay
	for key, value in overlay
		recipe[key] = value
	end
	recipe
end

def getRecipe target  # Load the key/value pairs of a recipe into a hash table
	(parent = (recipe = parseDictionary loadRecipe(target))['inherits']) ?
		overlayRecipe(getRecipe(parent), recipe) :
		recipe
end

def makeCommand port
	'make' + ((file = (getRecipe port)['makefile']) ? ' -f ' + file : '')
end

def sourcePackagesAvailable? target
	package = (packages = (getRecipe target)['packages']) ?
		(parseList packages).first :
		fullName(target)
	Dir[File.join(@sourcesPath, package + '.*')] != []
end

def action command  # Return the output of the shell command, or false if unsuccessful
	@log.action command
	stdout = `#{command}`
	if (status = $? >> 8) == 0  # OK
		@log.result stdout
		stdout
	else
		@log.error status
		@log.result stdout
		false
	end
end

class Log
attr_reader :failures

	def Log.path= path
		Dir.mkdir path unless exists? path

		@@logsPath = path
	end

	def Log.[] log
		IO.readlines File.join(@@logsPath, log)
	end

	def initialize
		@failures = []

		@log		= File.new File.join(@@logsPath, 'stdout'), 'w'
		@summary	= File.new File.join(@@logsPath, 'summary'), 'w'
		@failLog	= File.new File.join(@@logsPath, 'failures'), 'w'

		@log << s = "Building in root directory #{Dir.getwd}\n"
		@summary << s
		@failLog << s
	end

	def close
		@log << s = "\nFinished\n"
		@summary << s

		@log.close
		@summary.close
		@failLog.close
	end

	def header header
		print "\n" + s = header + "\n"
		@log << "\n#{s}\n"
		@summary << s
	end

	def subheader header
		print "\n" + s = header + "\n"
		@log << "\n#{s}\n"
		@summary << s
	end

	def entry entry
		print s = "\n#{entry}\n"
		@log << s
		@summary << s
	end

	def detail detail
		puts detail
		@log << detail + "\n"
	end

	def action action
		puts "\n#{action}\n"
		@log << action + ': '
		@summary << action
	end

	def warning error
		puts "\n" + s = 'Warning: ' + error
		@log << s + ':'
		@summary << ": #{s}\n"
	end

	def error error
		puts "\n" + s = "Error: #{error}"
		@log << s + ':'
		@summary << ": #{s}\n"
	end

	def result result
		@log << "\n\n" << result
		@summary << "\n"
	end

	def failure target
		@failLog << target + "\n"
		@failures << target
	end
end


# Define paths

@workDir = Dir.getwd

# Get the path to the application directory.
@builderPath = File.dirname File.dirname(dereference(File.expand_path($0)))

# Get global settings
@settings = parseDictionary loadFile(File.join(@builderPath, 'settings'))

@portsPath, Profile.path, @configPath, @resourcesPath, @distrosPath,    Log.path = [
'packages', 'profiles',   'sources',    'resources',    'distributions', 'logs'
].collect {|dir| File.join @builderPath, dir}

@sourcesPath = (dir = @settings['sources-path']) ? dir : @configPath

@iconsPath = '/system/icons'


# Set environment variables

for line in parseList @settings['environment']
	var, value = splitLine line
	ENV[var] = value
end

# Define settings

@syllable = ENV['OSTYPE'] == 'syllable'

# Confine ourselves to a subsection of CVS?
@cvsPath = '' unless @cvsPath = @settings['cvs-path']

# Include version number on installed ports?
@includeVersion = @settings['include-version']

@stage = File.join @workDir, 'stage'

unless @systemBuild = File.basename(@workDir) == 'system'
	@crossCompile = false
	@systemRoot = '/'
	@systemImage = '/boot'
else
	# System build; assume we're building Syllable for now
	@crossCompile = ! @syllable

	@systemImage = File.join(@stage, 'image')
	@systemRoot = File.join @systemImage, 'atheos'

#	@buildTools = File.join @workDir, 'build-tools'

#	ENV['DIST_VER'] = '0.5.6+'
#	ENV['DIST_NAME'] = 'base-syllable-0.5.6+.zip'

	ENV['ATHEOS_SRC'] = @workDir
#	ENV['BUILD_TOOLS'] = File.join @workDir, 'build-tools'
	ENV['DIST_DIR'] = @systemImage
end

@indexesRoot = File.join @systemImage, 'atheos/autolnk'

if @crossCompile
	@target = 'i586-pc-syllable' unless @target = @settings['target']

	ENV['CC']  = @target + '-gcc'
	ENV['CXX'] = @target + '-g++'
	ENV['AS']  = @target + '-as'
	ENV['LD']  = @target + '-ld'
	ENV['CFLAGS']   = "-b #{@target} " + (var = ENV['CFLAGS']   ? var : '')
	ENV['CXXFLAGS'] = "-b #{@target} " + (var = ENV['CXXFLAGS'] ? var : '')
	ENV['LDFLAGS']  = "-b #{@target} " + (var = ENV['LDFLAGS']  ? var : '')
end

# Isolate build in staging area from the build host?
@isolateStage = @crossCompile or @settings['isolate-stage']
# Or run newly built binaries and libraries on the build host to bootstrap?
@bootstrap = !@crossCompile and @settings['bootstrap']


# Main function

arg1, arg2, arg3 = ARGV

case arg1
when '-v', '--version'
	puts 'Syllable Build System 0.6.24',
		'Copyright (c) 2002-2005 Kaj de Vos',
		'License: GPL 2'
when '?', '-?', '-h', '-help', '--help'
	puts 'Usage:',
		'  build [<command>] [<module> | <profile> | <package> | <log>]',
		'  stage [<module> | <profile> | <package>]',
		'<command>:',
		'  -h, --help,   Show this help information',
		'    -help, ?, -?',
		'  -v, --version Show version information',
		'  scrub         Delete CVS control files recursively from the current directory',
		'  prepare       Initialize project image tree in staging area',
		'  get           Fetch and patch sources (deleting CVS control files)',
		'  download      Download sources (leaving CVS checkouts intact)',
		'  update        Update sources, or the build system itself, from repositories',
		'  unpack        Unpack sources from source packages',
		'  patch         Patch sources',
#		'  delete        Delete sources and build directories (or installation?)',
		'  distclean',
		'  clean',
		'  configure',
		'  make',
		'  test',
		'  install       (Run as super user)',
		'  uninstall     (Run as super user)',
#		'  register      (Run as super user)',
#		'  activate/elect   (Run as super user)',
#		'  unregister    (Run as super user)',
		'  stage         Build and install in the staging area',
		'  package       Build distribution package',
		'  pack          Build a compound package',
#		'  release       ',
		'  modules       List the modules of a profile',
		'  recipe        List a recipe',
		'  log           Show the last log',
		'<module>:       Module subdirectory',
		'<profile>:      Profile name',
		'  last          Last used profile',
		'  failures      Profile for last failures',
		'<package>:      Distribution package (install command only)',
		'<log>:          Log name',
		'  summary       Summarized log',
		'  failures      Log of failed modules'
when 'modules' then puts Profile.new(arg2)['modules']
when 'recipe'  then puts getRecipe(arg2).to_a
when 'log'     then print Log[arg2 ? arg2 : 'stdout']
else
	@log = Log.new

	if arg1 == 'scrub'
		deleteCVSData
	elsif arg1 == 'update' and not arg2
		@log.header 'Updating build system'

		Dir.chdir @builderPath
		action 'cvs -q update -dP'
	else
		target  = getTarget arg2 ? arg2 : arg1 ? arg1 : 'default'
		profile = target.profile

		Profile.new('last')['modules'] = profile['modules'] if profile  # Processing a profile

		if arg1 == 'prepare'
			prepare target
		else
			case arg1
			when 'get'			then get			target
			when 'download'		then download		target
			when 'update'		then update			target
			when 'unpack'		then unpack			target
			when 'patch'		then patch			target
			when 'uninstall'	then uninstall		target
			when 'package'		then buildPackages	target
			when 'pack'			then buildPack		target
			else
				if @systemBuild
					if exists? '/ainc'
						@log.header 'Temporarily replacing system headers'
						action "ln -snf #{File.join @workDir, 'sys/include'} /ainc"
					end

					# Pick up executables from the staging area

					if @bootstrap then ENV['PATH'] =
						(File.join @systemImage, 'atheos/sys/bin') +
#						Executables may not be position-independent:
#						':' + (File.join @systemImage, 'atheos/usr/glibc/bin') +
#						':' + (File.join @systemImage, 'atheos/usr/glibc/sbin') +
#						':' + (File.join @systemImage, 'atheos/usr/glibc2/bin') +
#						':' + (File.join @systemImage, 'atheos/usr/glibc2/sbin') +
#
#						':' + (File.join @stage, 'indexes/bin') +
						':' + (File.join @stage, 'bin') +
#						':' + (File.join @stage, 'indexes/sbin') +
						':' + (File.join @stage, 'sbin') +
#						Shouldn't really be used:
#						':' + (File.join @systemImage, 'atheos/usr/local/bin') +
#						':' + (File.join @systemImage, 'atheos/usr/bin') +
#						':' + (File.join @systemImage, 'atheos/usr/sbin') +
						(@isolateStage ? '' : ':' + ENV['PATH'])
					end

					# Pick up headers from the staging area and system repository

					headers =
						# New C library if it's there
						(File.join @systemImage, 'atheos/usr/glibc/include') +
						# C library headers
						':' + (File.join @systemImage, 'atheos/usr/glibc2/include') +
						# For GoboLinux
#						':' + '/Programs/Glibc/Current/include' +
						# System headers
						':' + (File.join @systemImage, 'atheos/sys/include') +
						':' + (File.join @workDir, 'sys/include') +
						# Linked headers
#						':' + (File.join @stage, 'indexes/include') +
						':' + (File.join @stage, 'include')
						# Extra headers
#						':' + (File.join @systemImage, 'atheos/usr/local/include') +
#						':' + (File.join @systemImage, 'atheos/usr/include')

					ENV['ATHEOS_INCLUDE_PATH'] = File.join @workDir, 'sys/include'
					ENV['C_INCLUDE_PATH'] = headers +
						((var = ENV['C_INCLUDE_PATH']) && !@isolateStage ? ':' + var : '')
					ENV['CPLUS_INCLUDE_PATH'] = headers +
						((var = ENV['CPLUS_INCLUDE_PATH']) && !@isolateStage ? ':' + var : '')

					# Pick up libraries from the staging area

					ENV['ATHEOS_LIB_PATH'] = File.join @systemImage, 'atheos/sys/libs'
					if @bootstrap then ENV['DLL_PATH'] =
						(File.join @systemImage, 'atheos/sys/libs') +
						':' + (File.join @systemImage, 'atheos/sys') +
#						':' + (File.join @stage, 'indexes/lib') +
						':' + (File.join @stage, 'lib') +
						((var = ENV['DLL_PATH']) && !@isolateStage ? ':' + var : '')
					end
					ENV[name = (@syllable ? '' : 'LD_') + 'LIBRARY_PATH'] =
						(File.join @systemImage, 'atheos/sys/libs') +
						(@syllable ? '' : ':' + File.join(@systemImage, 'atheos/sys')) +
						':' + (File.join @systemImage, 'atheos/usr/glibc/lib') +
						':' + (File.join @systemImage, 'atheos/usr/glibc2/lib') +
#						':' + (File.join @stage, 'indexes/lib') +
						':' + (File.join @stage, 'lib') +
#						':' + (File.join @systemImage, 'atheos/usr/local/lib') +
#						':' + (File.join @systemImage, 'atheos/usr/lib') +
						(@isolateStage ? '' : ':' + ENV[name])
				end

				case arg1
				when 'distclean'	then distclean	target
				when 'clean'		then clean		target
				when 'configure'	then configure	target
				when 'make'			then make		target
				when 'test'			then test		target
				when 'install'		then install	target
				when 'stage'
					build true, target if exists? @stage or prepare target
				else
					if arg2
						@log.error 'Unrecognized command'
						exit 1
					else
						build false, target
					end
				end

				if @systemBuild and exists? '/ainc'
					@log.header 'Restoring system headers'
					action 'ln -snf /system/include /ainc'
				end
			end

			Profile.new('failures')['modules'] = @log.failures if profile  # Processing a profile
		end
	end

	action 'sync'
	@log.close
	exit @log.failures.length  # FIXME: only works when processing a profile
end

