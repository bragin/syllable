#!/usr/bin/env ruby

# Syllable Build System
# Version 0.5.29
# Copyright (c) 2002-2004 Kaj de Vos
# License: GPL 2


# Functions for single modules

def unpackPackage target
	Dir.chdir File.dirname(target) if target['/']

	base = File.join @sourcesPath, ((pack = getRecipe(target)['packages']) ?
		pack :
		fullName(target)
	)
#	file = Dir[File.join(@sourcesPath, fullName target) + '.*'] [0]
#	case File.basename file
	unless
		if exists? file = base + '.tar.bz2' or exists? file = base + '.tbz2'
			gzip = false
			action "bzcat #{file} | tar x"
		elsif exists? file = base + '.tar.gz' or exists? file = base + '.tgz'
			gzip = true
			action 'tar xzf ' + file
		else
			@log.error "Source package #{base}.* not found"
			false
		end
	then
		false
	else
		if exists? dir = fullName(target)
			true
		else  # Tarball content has a deviating name
			@log.subheader 'Renaming source'

			unless result = action(gzip ? 'tar tzf ' + file : "bzcat #{file} | tar --list")
				false
			else
				action "mv #{File.dirname result.split[0]} " + dir
			end
		end
	end
end

def patchPackage target
	if exists? file = File.join(recipePath(target), fullName(target) + '.patch')
		@log.header 'Applying delta'
		return false unless action 'patch --strip=1 < ' + file
	end

	if exists? dir = patchesPath(target)
		@log.header 'Applying patches'
		return false unless action "cp -a #{File.join dir, '*'} ." and
			# Crude way to remove possible CVS dirs from patches - to be fixed
			deleteCVSData
	end

	unless
		if dirs = (recipe = getRecipe target)['patch-config']
			@log.header 'Patching configuration'
			files = File.join @sourcesPath, 'config/config.*'
	
			if dirs == ''
				action "cp -a #{files} ."
			else
				for dir in toList dirs
					return false unless action "cp -a #{files} #{dir}/"
				end
			end
		elsif dir = recipe['patch-legacy-config']
			@log.header 'Patching configuration'

			action "cp -a #{File.join @sourcesPath, 'config/legacy/*'} " +
				(dir == '' ? '.' : dir)
		else
			true
		end
	then
		false
	else
		if cmdLine = recipe['patch']
			@log.header 'Executing patch instructions'
			action toCommand(cmdLine)
		else
			true
		end
	end
end

def getPackage target
	unless
		unless exists? target
			@log.header 'Installing source'

			unless exists? dir = File.dirname(target) or action 'mkdir --parents ' + dir
				false
			else  # We have a destination dir
				unless unpackPackage target
					false
				else
					Dir.chdir @workDir
					Dir.chdir target

					patchPackage target
				end
			end
		else
			unless exists? File.join(target, 'CVS')
				# Source already prepared
				true
			else
				if Dir[File.join(@sourcesPath, fullName(target) + '.t*')] != []  # Some tarball
					puts "\nWARNING! This will clobber your CVS repository!"
					@log.header 'Replacing source'

					unless action 'rm -r ' + target
						@log.error 'Failed to delete source'
						false
					else
						unless unpackPackage target
							false
						else
							Dir.chdir @workDir
							Dir.chdir target

							patchPackage target
						end
					end
				else
					Dir.chdir target
					unless thirdParty?
						true
					else
						deleteCVSData
						patchPackage target
					end
				end
			end
		end
	then
		@log.error 'Source not (completely) installed'
		@log.failure target
		false
	else
		action 'sync'
	end
end

def configurePackage target
	unless thirdParty?
		@log.header 'Building dependencies'
		action 'make deps'

		true  # Continue building even if dependencies failed
	else
		unless
			if cmdLine = (recipe = getRecipe target)['configure']
				@log.header 'Configuring'
				action toCommand(cmdLine)
			else
				unless exists? cmd = (cmd = recipe['configure-cmd']) ? toString(cmd) : 'configure'
					# Nothing to be done here
					true
				else
					unless noBuildDir = recipe['no-build-dir'] or exists? dir = buildDir(target) or
						begin
							@log.header 'Creating build directory'
							action 'mkdir ' + dir
						end
					then
						false
					else
						@log.header 'Configuring'
	
						# Some packages require an absolute path to the configure command
						cmdPath = File.join(Dir.getwd, File.dirname(cmd))
						Dir.chdir noBuildDir ? File.dirname(cmd) : dir
	
						if exists? 'config.cache' and not action 'rm config.cache'
							false
						else
							if cmdLine = recipe['pre-configure'] and not action toCommand(cmdLine)
								false
							else
								action(((vars = recipe['configure-env']) ? toVariables(vars) + ' ' : '') +
									File.join((noBuildDir ? '.' : cmdPath), File.basename(cmd)) +
									((args = recipe['configure-args']) ?
										' ' + toString(args) :
										((p = recipe['configure-prefix']) ?
											' ' + p :
											' --prefix='
										) + prefix(target)
									) +
									((options = recipe['configure-options']) ? ' ' + toString(options) : '')
								)
							end
						end
					end
				end
			end
		then
			@log.failure target
			false
		else
			true
		end
	end
end

def cleanPackage target
	unless
		if exists? dir = buildDir(target)
			@log.header 'Deleting build directory'
			action 'rm -r ' + dir
		else
			action 'make clean'
		end
	then
#		@log.failure target
		false
	else
		action 'sync'
	end
end

def makePackage target
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless action(((vars = (recipe = getRecipe(target))['make-env']) ? toVariables(vars) + ' ' : '') +
		'make' +
		((vars = recipe['make-vars']) ? ' ' + toVariables(vars) : '') +
		((options = recipe['make-options']) ? ' ' + toString(options) : '') +
		((targets = recipe['make-targets']) ? ' ' + toString(targets) : '')
	)
		@log.failure target
		false
	else
		action 'sync'
	end
end

def testPackage target
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless action 'make ' +
		((options = (recipe = getRecipe(target))['test-options']) ? toString(options) + ' ' : '') +
		((targets = recipe['test-targets']) ? toString(targets) : 'check')
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def installPackage target
	unless
		if target[-4..-1] == '.tgz' and exists? target  # A distribution package
			# Packages are currently supposed to contain an unversioned directory
			root = File.join(File.dirname(installPath(target)), shortName(target))

			if exists? root and not
				begin
					@log.header 'Uninstalling ' + shortName(target)
					uninstallPackage target  # Double failure logging!
				end
			then
				false
			else
				@log.header 'Unpacking ' + target
				action 'tar --directory=/usr -xpPzf ' + target and
				begin
					@log.header 'Registering ' + target
					action 'pkgmanager -a ' + root
				end
			end
		else
			Dir.chdir target

			unless thirdParty?
				if exists? dir = buildDir(target) then Dir.chdir dir end
				action 'make install'
			else
				root = installPath target

				if exists? root and not
					begin
						@log.header 'Uninstalling ' + shortName(target)
						uninstallPackage target  # Double failure logging!
					end
				then
					false
				else
					if dirs = (recipe = getRecipe target)['install-tree']
						@log.header 'Creating subdirectories'
						@log.detail root
						Dir.mkdir root

						for dir in toList dirs
							@log.detail d = File.join(root, dir)
							Dir.mkdir d
						end
					end

					if exists? dir = buildDir(target) then Dir.chdir dir end

					if not action(
						if cmdLine = recipe['install']
							toCommand cmdLine
						else
							((vars = recipe['install-env']) ? toVariables(vars) + ' ' : '') +
							'make' +
							(	(var = recipe['install-prefix-var']) ? " #{var}=" + root :
								@systemBuild ? ' prefix=' + root :
								''
							) +
							' install'
#							' install-strip'
						end
					)
						false
					elsif files = recipe['documentation'] and not
						begin
							@log.header 'Installing documentation'
							Dir.chdir @workDir
							Dir.chdir target
							action "cp -a #{toString files} " + root
						end
					then
						false
					elsif exists? filesPath = File.join(@packagesPath, fullName(target), 'distro') and not
						begin
							@log.header 'Installing extra files'
							action "cp -a #{File.join filesPath, '*'} " + root and
							begin
								# Crude way to remove possible CVS dirs from files - to be fixed
								Dir.chdir root
								deleteCVSData
							end
						end
					then
						false
					elsif links = recipe['links'] and not
						begin
							@log.header 'Creating links'

							for link in parseList links
								original, destination = toList link
								linkPath = File.dirname destination
								linkFile = File.basename destination

								if linkPath[0, 1] == '/'  # A link into the system
									original = File.join prefix(target), original if original['/']

									if @systemBuild
										linkPath = File.join @systemRoot,
											linkPath[0, 5] == '/usr/' ?
												'' :
												'sys',  # A link into the core system
											linkPath
									end
								else  # A link within the package
									linkPath = File.join root, linkPath
								end

								break unless action "cd #{linkPath} && ln -sf #{original} " + linkFile
							end
						end
					then
						false
					else
						@systemBuild or
						begin
							@log.header 'Registering ' + target
							action 'pkgmanager -a ' + root
						end
					end
				end
			end
		end
	then
		@log.failure target
	else
		action 'sync'
	end
end

def uninstallPackage target
	unless
		if dir? target and not
			begin
				Dir.chdir target
				thirdParty?
			end
		then  # A native module
			if exists? dir = buildDir(target) then Dir.chdir dir end
			action 'make uninstall'
		else
			dir = installPath target
			name = shortName target

			unless @systemBuild or
				begin
					@log.header 'Unregistering ' + name
					action 'pkgmanager -r ' + dir
				end
			then
				false
			else
				@log.header 'Deleting ' + name
				action 'rm -r ' + dir
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def makeDistroPackage target  # Should only be called if it's a system build
	unless exists? target
		@log.error 'Source not installed'
		@log.failure target
	else
		Dir.chdir target

		if thirdParty?
			Dir.chdir @workDir
			installPackage target
		else
			if exists? dir = buildDir(target) then Dir.chdir dir end

			unless
				unless action 'make dist'
					false
				else
#					@log.header 'Installing documentation'
#					if action 'make doc'
#						action 'make install-doc'
#					end

					true
				end
			then
				@log.failure target
			else
				action 'sync'
			end
		end
	end
end

def buildPackage target
	if getPackage target  # Source is available
		Dir.chdir @workDir  # Target path may be relative or absolute
		Dir.chdir target

		@log.header 'Cleaning'
		cleanPackage target

		if configurePackage target  # No failed configuration
			# Build the directory
			@log.header 'Making'
			makePackage target
		end
	end

	Dir.chdir @workDir
end


# Functions for multiple modules

def doModules command, target
	# Visit all directories

	for package in target.modules
		@log.entry package

		Dir.chdir package
		action command
		Dir.chdir @workDir
	end
end

def prepare target
	if @systemBuild and target.profile and tree = target.profile['distro-tree']
		@log.header 'Building distribution tree'

		if exists? @stage
			action 'rm -r ' + File.join(@stage, '*')
		else
			Dir.mkdir @stage
		end
		Dir.chdir @stage

#		action File.join(@buildTools, 'mkbase.sh') + ' ' + @stage
		for dir in toList tree
			@log.detail dir
			Dir.mkdir dir unless exists? dir
		end

		Dir.chdir @workDir
		action 'sync'
	end
end

def patch target
	@log.header 'Patching ' + target.to_s

	# Patch all directories

	for package in target.modules
		@log.entry package

		Dir.chdir package
		unless patchPackage package
			@log.error 'Source not patched'
			@log.failure target.to_s
		end
		Dir.chdir @workDir
	end
end

def get target
	@log.header 'Fetching ' + target.to_s

	# Fetch all directories

	for package in target.modules
		@log.entry package
		getPackage package
	end
end

def distclean target
	@log.header 'Cleaning distribution ' + target.to_s
	doModules 'make distclean', target
end

def configure target
	@log.header 'Configuring ' + target.to_s

	# Configure all directories

	for package in target.modules
		@log.entry package

		Dir.chdir package
		configurePackage package
		Dir.chdir @workDir
	end
end

def clean target
	@log.header 'Cleaning ' + target.to_s

	# Clean all directories

	for package in target.modules
		@log.entry package

		Dir.chdir package
		cleanPackage package
		Dir.chdir @workDir
	end
end

def make target
	@log.header 'Making ' + target.to_s

	# Make all directories

	for package in target.modules
		@log.entry package

		Dir.chdir package
		makePackage package
		Dir.chdir @workDir
	end
end

def test target
	@log.header 'Testing ' + target.to_s

	# Test all directories

	for package in target.modules
		@log.entry package

		Dir.chdir package
		testPackage package
		Dir.chdir @workDir
	end
end

def install target
	@log.header 'Installing ' + target.to_s

	# Install all directories or distribution packages

	for package in target.modules
		@log.entry package

		installPackage package
		Dir.chdir @workDir
	end
end

def uninstall target
	@log.header 'Uninstalling ' + target.to_s

	# Uninstall all directories

	for package in target.modules
		@log.entry package

		uninstallPackage package
		Dir.chdir @workDir
	end
end

def makeDistro target
	@log.header 'Making distribution ' + target.to_s

	modules = target.modules

	if @systemBuild
		# Visit all directories

		for package in modules
			@log.entry package
			makeDistroPackage package
			Dir.chdir @workDir
		end
	else  # Create a single package
		file = (name = fullName target.to_s) + '.bin.1'

		unless
			unless modules.is_a? Array and exists? distroDir = File.join(@packagesPath, name, 'distro')
				action "tar -cvzf #{file}.tgz" +
					" --directory=#{@installRoot} " +
						installName(name) +
#						toString(modules.collect {|package| installName package}) +
					(	(links = (links = parseList(getRecipe(name)['links'])) ?
							links.collect { |link|
								(destination = toList(link)[1])[0, 1] == '/' ?  # A link into the system
									destination :
									nil
							}.compact :
							[]
						) == [] ?
							'' :
							' --absolute-names ' + toString(links)
					)
			else  # A compound package
				unless action "mkdir " + name
					false
				else
					unless action "cp -a #{File.join distroDir, '*'} " + name
						false
					else
						Dir.chdir name

						unless
							deleteCVSData
						then
							false
						else
							Dir.chdir @workDir

							unless
								for package in modules
									# Try to find the latest release
									break unless action "ln -s #{Dir[
											File.join(@distrosPath, fullName(package)) + '.bin.*.tgz'
										].last
									} " + name
								end
							then
								false
							else
								action "tar --dereference --remove-files -cvzf #{file}.tgz " + name
							end
						end
					end
				end
			end
		then
			@log.failure target.to_s
		else
			action 'sync'
		end
	end
end

def build target
	@log.header 'Building ' + target.to_s

	# Build all directories

	for package in target.modules
		@log.entry package
		buildPackage package
	end
end


# Helper functions

def deleteCVSData
	puts "\nWARNING! This will clobber your CVS repository!"

	# Delete all CVS dirs
	# (They would trigger some packages to reconfigure themselves.)
	@log.header 'Cleaning out CVS dirs'

	Dir['**/CVS'].each do |dir|
		@log.detail dir

		# Delete all files in the CVS dir first
		Dir.foreach dir do |file|
			f = File.join dir, file
			File.delete f if File.stat(f).file?
		end

		Dir.delete dir
	end

	@log.header 'Cleaning out .cvsignore files'

	Dir['**/.cvsignore'].each do |file|
		@log.detail file
		File.delete file
	end
end

def exists? file
	FileTest.exists? file
end

def dir? file
	FileTest.directory? file
end

def loadFile file  # Load the lines of a file into an array, discarding comments and empty lines
	lines = []

	File.open file do |file|
		file.each do |line|
			# Get rid of record delimiter, comments and empty lines
			lines += [line.chomp] unless line.chomp == '' or line[0, 1] == ';'
		end
	end

	lines
end

def saveFile data, file  # Write an array to a text file
	File.open file, 'w' do |file|
		for line in data
			file << line + "\n"
		end
	end
end

def parseDictionary text  # Load key/value pairs into a hash table
	hash = {}

	for line in text
		if line !~ /^\s+/  # A key line
			unless line[/\s/]  # A single key
				hash[lastKey = line] = ''
			else  # A key with a single value
				key, value = splitLine line
				hash[key] = value
			end
		else  # Starts with whitespace, so it's a list value
			if hash[lastKey] == ''
				hash[lastKey] = [line.strip]
#				margin = $&
			else
				hash[lastKey] << line.strip
			end
		end
	end

	hash
end

def parseList value  # Normalize value into an array
	if value.is_a? String
		if value == ''
			[]
		else
			[value]
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def splitLine line
	i = line.index(/\s/)  # First whitespace
	[line[0, i], line[i + 1 .. line.length - 1].strip]
end

def toList value  # Force values into an array
	if value.is_a? String
		if value == ''
			[]
		else
			value.split
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def toString value  # Join list value into a space-separated string
	if value.is_a? Array
		value.join(' ')
	else  # Assume it's already a string, or nil
		value
	end
end

def toCommand value  # Join list value into a semicolon-separated shell command string
	if value.is_a? Array
		value.join(' && ')
	else  # Assume it's already a string, or nil
		value
	end
end

def toVariables value  # Join an array of environment variables into shell syntax
	toString((parseList value).collect do |line|
		var, value = splitLine line
		var + '=' + value
	end)
end

def fullName package
	# Extract name including version, if necessary
	File.basename package[-1, 1] == '/' ? package.chop : package
end

def shortName package
	# Extract name without version
	/(-\d)|$/.match(fullName(package)).pre_match
end

def installName package
	package = fullName package
	@includeVersion && ! @systemBuild ?
		package :
		shortName(package)
end

def prefix package
	File.join '/usr', installName(package)
end

def installPath package
	File.join @installRoot, installName(package)
end

def recipePath package
	File.join @packagesPath, fullName(package)
end

def patchesPath package
	File.join recipePath(package), 'patches'
end

def buildDir package
	'../=' + fullName(package)
end

def thirdParty?
	exists? ((cmd = getRecipe(dir = Dir.getwd)['configure-cmd']) ? toString(cmd) : 'configure') or
		shortName(dir) == 'bzip2'
# Currently conflicts with Ffmpeg:
#		exists? File.join(@packagesPath, package = fullName(Dir.getwd), package + '.recipe')
end

class Profile
attr_reader :profile

	def Profile.path= path
		@@profilesPath = path
	end

	def initialize target
		@profile = exists?(@file = File.join(@@profilesPath, target)) ?
			parseDictionary(loadFile(@file)) :
			nil
	end

	def [] key
		(value = @profile[key]) ?
			value :
		exists?(file = File.join(@file, key)) ?
			loadFile(file) :
			nil
	end

	def []= key, value
		saveFile [key] + value.collect {|line| "\t" + line}, @file  # File.join(@file, key)
	end
end

def getTarget target
	profile = nil
	Struct.new(:to_s, :modules, :profile).new(
		target,
		# Get the list of modules for the build target, or a single module
		if target['/']  # A single target directory
			target[-1, 1] == '/' ? target.chop : target
		elsif (p = Profile.new target).profile  # A profile
			toList (profile = p)['modules']
		else
			target
		end,
		profile
	)
end

def loadRecipe package  # Read a recipe file
	if exists? file = File.join(recipePath(package = fullName(package)), package + '.recipe')
		loadFile file
	else
		[]
	end
end

def getRecipe package  # Load the key/value pairs of a recipe into a hash table
	parseDictionary loadRecipe(package)
end

def overlayRecipe recipe, overlay
	for key, value in overlay
		recipe[key] = value
	end
	recipe
end

def action command  # Return the output of the shell command, or false if unsuccessful
	@log.action command
	stdout = `#{command}`
	if (status = $? >> 8) == 0  # OK
		@log.result stdout
		stdout
	else
		@log.error status
		@log.result stdout
		false
	end
end

class Log
attr_reader :failures

	def Log.path= path
		Dir.mkdir path unless exists? path

		@@logsPath = path
	end

	def Log.[] log
		IO.readlines File.join(@@logsPath, log)
	end

	def initialize
		@failures = []

		@log		= File.new File.join(@@logsPath, 'stdout'), 'w'
		@summary	= File.new File.join(@@logsPath, 'summary'), 'w'
		@failLog	= File.new File.join(@@logsPath, 'failures'), 'w'

		@log		<< s = "Building in root directory #{Dir.getwd}\n"
		@summary	<< s
		@failLog	<< s
	end

	def close
		@log		<< s = "\nFinished\n"
		@summary	<< s

		@log.close
		@summary.close
		@failLog.close
	end

	def header header
		print		"\n" + s = header + "\n"
		@log		<< "\n#{s}\n"
		@summary	<< s
	end

	def subheader header
		print		"\n" + s = header + "\n"
		@log		<< "\n" + s
		@summary	<< s
	end

	def entry entry
		print		s = "\n#{entry}\n"
		@log		<< s
		@summary	<< s
	end

	def detail detail
		puts		detail
		@log		<< detail + "\n"
	end

	def action action
		puts		"\n#{action}\n"
		@log		<< action + ': '
		@summary	<< action
	end

	def error error
		puts		"\n" + s = "Error: #{error}"
		@log		<< s + ':'
		@summary	<< ': ' + s
	end

	def result result
		@log		<< "\n\n" << result
		@summary	<< "\n"
	end

	def failure target
		@failLog	<< target + "\n"
		@failures	<< target
	end
end


# Define paths

@workDir		= Dir.getwd

# Get the path to the application directory
@builderPath	= File.dirname(File.dirname(FileTest.symlink?($0) ?
	File.readlink($0) :
	$0
))
@packagesPath, Profile.path, @sourcesPath, @distrosPath,    Log.path = [
'packages',    'profiles',   'sources',    'distributions', 'logs'
].collect {|dir| File.join @builderPath, dir}

# Define settings

@settings = parseDictionary loadFile(File.join(@builderPath, 'settings'))

# Include version number on installed packages?
@includeVersion = @settings['include-version']

unless @systemBuild = File.basename(@workDir) == 'system'
	@systemRoot = '/'
	@installRoot = '/usr'
else
	@stage = File.join @workDir, 'dist-root'
#	@buildTools = File.join @workDir, 'build-tools'

	@installRoot = File.join @systemRoot = File.join(@stage, 'atheos'), 'usr'

	ENV['DIST_VER']  = '0.5.3+'
	ENV['DIST_NAME'] = 'base-syllable-0.5.3+.tgz'

	ENV['ATHEOS_SRC']	= @workDir
	ENV['BUILD_TOOLS']	= File.join @workDir, 'build-tools'
	ENV['DIST_DIR']		= @stage
end

# Set environment variables

for line in parseList @settings['environment']
	var, value = splitLine line
	ENV[var] = value
end


# Main function

arg1, arg2, arg3 = ARGV

case arg1
when '-v', '--version'
	puts 'Syllable Build System 0.5.29',
		'Copyright (c) 2002-2004 Kaj de Vos',
		'License: GPL 2'
when '?', '-?', '-h', '-help', '--help'
	puts 'Usage: build [<command>] [<module> | <profile> | <distribution> | <log>]',
		'<command>:',
		'  -h, --help,   Show this help information',
		'    -help, ?, -?',
		'  -v, --version Show version information',
		'  scrub         Delete CVS control files recursively from the current directory',
		'  prepare       Initialize system distribution tree',
		'  get           Fetch and patch sources',
		'  patch         Patch sources',
		'  distclean',
		'  clean',
		'  configure',
		'  make',
		'  test',
		'  install       (Run as super-user)',
		'  uninstall     (Run as super-user)',
		'  distro        Build a distribution package or a system distribution',
		'  modules       List the modules of a profile',
		'  recipe        List a recipe',
		'  log           Show the last log',
		'<module>:       Package subdirectory',
		'<profile>:      Profile name',
		'  last          Last used profile',
		'  failures      Profile for last failures',
		'<distribution>: Distribution package ((un)install command only)',
		'<log>:          Log name',
		'  summary       Summarized log',
		'  failures      Log of failed modules'
when 'modules'	then puts Profile.new(arg2)['modules']
when 'recipe'	then puts loadRecipe(arg2)
when 'overlay'	then puts overlayRecipe(getRecipe(arg2), getRecipe(arg3)).to_a
when 'log'		then print Log[arg2 ? arg2 : 'stdout']
else
	@log = Log.new

	if arg1 == 'scrub'
		deleteCVSData
	else
		target  = getTarget arg2 ? arg2 : arg1 ? arg1 : 'default'
		profile = target.profile

		Profile.new('last')['modules'] = profile['modules'] if profile  # Processing a profile

		if arg1 == 'prepare'
			prepare target
		else
			if @systemBuild
				@log.header 'Temporarily replacing system headers'
				action "ln -sf #{File.join @workDir, 'sys/include'} /ainc"

				ENV['ATHEOS_INCLUDE_PATH'] = File.join @workDir, 'sys/include'
				ENV['C_INCLUDE_PATH'] =
					(File.join @stage, 'boot/atheos/sys/include') + ':' +
					(File.join @stage, 'boot/atheos/autolnk/include') + ':' +
					ENV['C_INCLUDE_PATH']
				ENV['CPLUS_INCLUDE_PATH'] =
					(File.join @stage, 'boot/atheos/sys/include') + ':' +
					(File.join @stage, 'boot/atheos/autolnk/include') + ':' +
					ENV['CPLUS_INCLUDE_PATH']

				ENV['ATHEOS_LIB_PATH'] = File.join @workDir, 'libs'
				ENV['DLL_PATH'] =
					(File.join @stage, 'boot/atheos/sys/libs') + ':' +
					(File.join @stage, 'boot/atheos/sys') + ':' +
					(File.join @stage, 'boot/atheos/autolnk/lib') + ':' +
					ENV['DLL_PATH']
				ENV['LIBRARY_PATH'] =
					(File.join @stage, 'boot/atheos/sys/libs') + ':' +
					(File.join @stage, 'boot/atheos/autolnk/lib') + ':' +
					ENV['LIBRARY_PATH']

				prepare target unless exists? @stage
			end
	
			case arg1
			when 'get'			then get		target
			when 'patch'		then patch		target
			when 'distclean'	then distclean	target
			when 'clean'		then clean		target
			when 'configure'	then configure	target
			when 'make'			then make		target
			when 'test'			then test		target
			when 'install'		then install	target
			when 'uninstall'	then uninstall	target
			when 'distro'		then makeDistro	target
			else
				if arg2
					@log.error 'Unrecognized command'
					exit
				else
					build target
				end
			end
	
			if @systemBuild
				@log.header 'Restoring system headers'
				action 'ln -sf /system/include /ainc'
			end
	
			Profile.new('failures')['modules'] = @log.failures if profile  # Processing a profile
		end
	end

	action 'sync'
	@log.close
end
