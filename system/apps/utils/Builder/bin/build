#! ruby

# Syllable Build System
# Version 0.1.2
# Copyright (c) 2002, 2003 Kaj de Vos
# License: GPL 2


# Define paths

@builderDir		= "/Applications/Builder"
@profilesDir	= File.join @builderDir, "profiles"
@sourcesDir	= File.join @builderDir, "sources"
@packagesDir	= File.join @builderDir, "packages"
@logDir			= File.join @builderDir, "logs"

@workDir		= Dir.getwd
@distroRoot		= File.join @workDir, "dist-root"
#@buildTools		= File.join @workDir, "build-tools"

# Define settings

@installRoot = (@systemBuild = File.basename(@workDir) == "system") ?
	File.join(@distroRoot, "atheos/usr") :
	"/usr"
@includeVersion = false
#@includeVersion = true

# Set environment variables

ENV['CFLAGS']	= "-march=i586 -O2 -pipe"
ENV['CXXFLAGS']	= "-march=i586 -O2 -pipe"

if @systemBuild
	ENV['DIST_VER']  = "0.5.1x"
	ENV['DIST_NAME'] = "base-syllable-0.5.1x.tgz"

	ENV['ATHEOS_SRC']			= @workDir
	ENV['ATHEOS_INCLUDE_PATH']	= File.join @workDir, "sys/include"
	ENV['ATHEOS_LIB_PATH']		= File.join @workDir, "libs"
	ENV['BUILD_TOOLS']			= File.join @workDir, "build-tools"
	ENV['DIST_DIR']				= @distroRoot
end


# Functions for single packages

def unpackPackage target
	Dir.chdir File.dirname target if target["/"]

#	file = Dir[File.join(@sourcesDir, fullName target) + ".*"] [0]
#	case File.basename file
	if exists file = (base = File.join @sourcesDir, fullName target) + ".tar.bz2" or
		exists file = base + ".tbz2"
	then
		action "bzcat #{file} | tar x"
	elsif exists file = base + ".tar.gz" or exists file = base + ".tgz"
		action "tar xzf " + file
	else
		logError "Source not found"
		false
	end
end

def patchPackage target
	if exists dir = patchesDir(target)
		logHeader "Patching source"
		return false unless action "cp -a #{File.join dir, "*"} ."
	end

	if dir = (recipe = recipe target)["patch-config"]
		logHeader "Patching configuration"
		action "cp -a #{File.join @sourcesDir, "config/config.*"} " +
			(dir == "" ? "." : dir)
	elsif dir = recipe["patch-legacy-config"]
		logHeader "Patching configuration"
		action "cp -a #{File.join @sourcesDir, "config/legacy/*"} " +
			(dir == "" ? "." : dir)
	else
		true
	end
end

def getPackage target
	if	unless exists target
			logHeader "Installing source"

			if unpackPackage target
				Dir.chdir @workDir
				Dir.chdir target

				patchPackage target
			else
				false
			end
		else
			unless exists File.join target, "CVS"
				# Source already prepared
				true
			else
				puts "\nWARNING! This will clobber your CVS repository!"

				if exists File.join @sourcesDir, fullName(target) + ".*"
					logHeader "Replacing source"

					if action "rm -r " + target
						if unpackPackage target
							Dir.chdir @workDir
							Dir.chdir target

							patchPackage target
						else
							false
						end
					else
						logError "Failed to delete source"
						false
					end
				else
					Dir.chdir target
					deleteCVSData
				end
			end
		end
	then
		true
	else
		logError "Source not installed"
		logFailure target
		false
	end
end

def configurePackage target
	if exists "configure"  # configure command available
		logHeader "Configuring"
		action "rm config.cache"
		name = shortName package = fullName(target)
		if action "./configure" +
			((options = recipe(package)["configure-options"]) ? " " + options : "") +
			(name == "man" || name == "grub" ? "" :
				" --prefix=" + prefix(package)
			)
		then true
		else
			logFailure target
			false
		end
	else
		logHeader "Building dependencies"
		action "make deps"

		true  # Continue building even if dependencies failed
	end
end

def cleanPackage target
	action "make clean"
end

def makePackage target
	unless action "make"
		logFailure target
	end
end

def testPackage target
	action "make check"
end

def installPackage target
	dir = installDir target

	unless action "make" +
		(@systemBuild ? " prefix=" + dir : "") +
		" install"
#		" install-strip"
	then
		logFailure target
	else
		logHeader "Installing extra files"

		action "cp -a #{files} " + dir if files = recipe(target)["documentation"]

		if exists distroDir = File.join(@packagesDir, fullName(target), "distro")
			# Extra files available
			action "cp -a #{File.join distroDir, "*"} " + dir
		end

		unless @systemBuild
			logHeader "Registering " + dir
			logFailure target unless action "pkgmanager -a " + dir
		end
	end
end

def uninstallPackage target
	p = prefix target
	if @systemBuild or action "pkgmanager -r " + p
		logHeader "Deleting " + p
		action "rm -r " + p
	end
end

def makeDistroPackage target
	if exists "configure"  # 3rd-party package
		installPackage target
	else  # Native package
		if action "make dist"
			logHeader "Installing documentation"
			if action "make doc"
				action "make install-doc"
			end
		else
			logFailure target
		end
	end
end

def buildPackage target
	if getPackage target  # Source is available
		Dir.chdir @workDir
		Dir.chdir target

		logHeader "Cleaning"
		cleanPackage target

		if configurePackage target  # No failed configuration
			# Build the directory
			logHeader "Making"
			makePackage target
		end
		Dir.chdir @workDir
	end
end


# Functions for multiple packages

def doPackages command, target
	# Visit all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		action command
		Dir.chdir @workDir
	end
end

def prepare
	if @systemBuild
		logHeader "Creating extra directories"

		for dir in load File.join(@builderDir, "extra-source-dirs")
			Dir.mkdir dir unless exists dir
		end

		logHeader "Building distribution tree"

		if exists @distroRoot
			action "rm -r " + File.join(@distroRoot, "*")
		else
			Dir.mkdir @distroRoot
		end
		Dir.chdir @distroRoot

#		action File.join(@buildTools, "mkbase.sh") + " " + @distroRoot
		for dir in load File.join(@builderDir, "distro-dirs")
			Dir.mkdir dir unless exists dir
		end
	end
end

def patch target
	logHeader "Patching " + target

	# Patch all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		unless patchPackage package
			logError "Source not patched"
			logFailure target
		end
		Dir.chdir @workDir
	end
end

def get target
	logHeader "Fetching " + target

	# Fetch all directories

	for package in profile target
		logEntry package
		getPackage package
	end
end

def distclean target
	logHeader "Cleaning distribution " + target
	doPackages "make distclean", target
end

def configure target
	logHeader "Configuring " + target

	# Configure all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		configurePackage package
		Dir.chdir @workDir
	end
end

def clean target
	logHeader "Cleaning " + target

	# Clean all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		cleanPackage package
		Dir.chdir @workDir
	end
end

def make target
	logHeader "Making " + target

	# Make all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		makePackage package
		Dir.chdir @workDir
	end
end

def test target
	logHeader "Testing " + target

	# Test all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		testPackage package
		Dir.chdir @workDir
	end
end

def install target
	logHeader "Installing " + target

	# Install all directories

	for package in profile target
		logEntry package

		Dir.chdir package
		installPackage package
		Dir.chdir @workDir
	end
end

def uninstall target
	logHeader "Uninstalling " + target

	# Uninstall all directories

	for package in profile target
		logEntry package
		uninstallPackage package
	end
end

def makeDistro target
	logHeader "Making distribution " + target

	profile = profile(target)
	if @systemBuild
		# Visit all directories

		for package in profile
			logEntry package
			Dir.chdir package
			makeDistroPackage package
			Dir.chdir @workDir
		end
	else  # Create a single package
		file = (name = fullName target) + ".bin.1"

		if  # Tar it up
			if action "tar cvf #{file}.tar" +
				" -C #{@installRoot} " +
					(profile.collect {|package| installName package}).join(" ") +
				(files = recipe(target)["distro-files"] ? " " + files : "")
			then
				if profile.is_a? Array and exists distroDir = File.join(@packagesDir, name, "distro")
					# It's a compound package; add extra files
					Dir.chdir distroDir
					action "tar rvf #{File.join @workDir, file}.tar *"
					Dir.chdir @workDir
				else
					true
				end
			end
		then
			# Zip it up
			if action "gzip #{file}.tar"
				action "mv #{file}.tar.gz #{file}.tgz"
			end
		end
	end
end

def build target
	logHeader "Building " + target

	# Build all directories

	for package in profile target
		logEntry package
		buildPackage package
	end
end


# Helper functions

def deleteCVSData
	# Delete all CVS dirs
	# (They would trigger some packages to reconfigure themselves.)

	logHeader "Cleaning out CVS dirs"

	Dir["**/CVS"].each do |dir|
		@log << dir + "\n"

		# Delete all files in the CVS dir first
		Dir.foreach dir do |file|
			f = File.join dir, file
			File.delete f if File.stat(f).file?
		end

		Dir.delete dir
	end
end

def exists file
	Dir[file] != []
end

def load file  # Load the lines of a file into an array, leaving out comments
	lines = []

	File.open file do |file|
		file.each do |line|
			# Get rid of record delimiter and comments
			lines += [line.chomp] unless line =~ /\s*;/
		end
	end

	lines
end

def save data, file  # Write an array to a text file
	File.open file, "w" do |file|
		for line in data
			file << line + "\n"
		end
	end
end

def parseValues text  # Load key/value pairs into a hash table
	hash = {}

	for line in text
		if i = line.index(/\s/)
			hash[line[0, i]] = line[i + 1 .. line.length - 1].strip
		else
			hash[line] = ""
		end
	end

	hash
end

def fullName package
	# Extract name including version, if necessary
	File.basename package[-1, 1] == "/" ? package.chop : package
end

def shortName package
	# Extract name without version
	/(-\d)|$/.match(fullName(package)).pre_match
end

def installName package
	package = fullName package
	@includeVersion && ! @systemBuild ?
		package :
		shortName(package)
end

def prefix package
	File.join "/usr", installName(package)
end

def installDir package
	File.join @installRoot, installName(package)
end

def patchesDir package
	File.join @packagesDir, fullName(package), "patches"
end

def profile target  # Return the list of packages for the build target
	if target["/"]  # A single directory
		target[-1, 1] == "/" ? target.chop : target
	else  # A profile
		load File.join(@profilesDir, target)
	end
end

def recipe package  # Load the key/value pairs of a recipe into a hash table
	package = fullName package
	if exists recipe = File.join(@packagesDir, package, package + ".recipe")
		parseValues load recipe
	else
		{}
	end
end

def action command
	logAction command
	stdout = `#{command}`
	status = $? >> 8
	logError status unless ok = status == 0
	logResult stdout
	ok
end

def openLogs
	@failures = []

	Dir.mkdir @logDir unless exists @logDir

	@log		= File.new File.join(@logDir, "last-stdout"), "w"
	@summary	= File.new File.join(@logDir, "last-summary"), "w"
	@failLog		= File.new File.join(@logDir, "last-failures"), "w"

	@log		<< s = "Building in root directory #{@workDir}\n"
	@summary	<< s
	@failLog		<< s
end

def closeLogs
	@log		<< s = "\nFinished\n"
	@summary	<< s

	@log.close
	@summary.close
	@failLog.close
end

def logHeader header
	print			"\n" + s = header + "\n"
	@log		<< "\n#{s}\n"
	@summary	<< s
end

def logSubheader header
	print			"\n" + s = header + "\n"
	@log		<< "\n" + s
	@summary	<< s
end

def logEntry entry
	print			s = "\n#{entry}\n"
	@log		<< s
	@summary	<< s
end

def logAction action
	puts			"\n#{action}\n"
	@log		<< action + ": "
	@summary	<< action
end

def logError error
	puts			"\n" + s = "Error: #{error}"
	@log		<< s + ":"
	@summary	<< ": " + s
end

def logResult result
	@log		<< "\n\n#{result}\n\n"
	@summary	<< "\n"
end

def logFailure target
	@failLog << target + "\n"
	@failures << target
end


# Main function

arg1, arg2 = ARGV[0], ARGV[1]

case arg1
when "--version"
	puts "Syllable Build System 0.1.2",
		"Copyright (c) 2002, 2003 Kaj de Vos",
		"License: GPL 2"
when "--help"
	puts "Usage: build [<command>] [<package> | <profile>]",
		"<command>:",
		"  --version",
		"  --help",
		"  prepare:       Initialize source and distribution trees",
		"  get:           Fetch and patch sources",
		"  patch:         Patch sources",
		"  distclean",
		"  clean",
		"  configure",
		"  make",
		"  test",
		"  install:       Run as super-user",
		"  uninstall:     Run as super-user",
		"  distro",
		"  log",
		"  summary",
		"  failures",
		"<package>:       Package subdirectory",
		"<profile>:       Profile name",
		"  last:          Last used profile",
		"  last-failures: Profile for last failures"
when "log"		then print IO.readlines(File.join(@logDir, "last-stdout"))
when "summary"	then print IO.readlines(File.join(@logDir, "last-summary"))
when "failures"	then print IO.readlines(File.join(@logDir, "last-failures"))
else
	target = arg2 ? arg2 : arg1 ? arg1 : "default"

	openLogs

	save profile(target), File.join(@profilesDir, "last")

	if @systemBuild
#		File.delete "/ainc" if exists "/ainc"
#		action "ln -s #{File.join @workDir, "sys/include"} /ainc"

		prepare unless exists @distroRoot
	end

	case arg1
	when "prepare"	then prepare
	when "get"		then get target
	when "patch"		then patch target
	when "distclean"	then distclean target
	when "clean"		then clean target
	when "configure"	then configure target
	when "make"		then make target
	when "test"		then test target
	when "install"		then install target
	when "uninstall"	then uninstall target
	when "distro"		then makeDistro target
	else build arg1 ? arg1 : "default"
	end

	save @failures, File.join(@profilesDir, "last-failures")

	if @systemBuild
#		File.delete "/ainc"
#		action "ln -s /system/include /ainc"
	end

	closeLogs
end
