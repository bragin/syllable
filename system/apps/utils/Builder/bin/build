#!/usr/bin/env ruby

# Syllable Build System
# Version 0.6.120
# Copyright (c) 2002-2007 Kaj de Vos
# License: GPL 2 or any later version


# Functions for single modules

def prepare target
	@log.header 'Creating staging area'

	if exists? @stage
		@log.header 'Deleting old staging area'
		action 'rm --recursive --force ' + File.join(@stage, '*')
	else
		Dir.mkdir @stage
	end

	for dir in ['etc', 'bin', 'sbin', 'include', 'lib', 'libexec', 'man', 'info', 'share', 'early-init', 'init']
		Dir.mkdir File.join(@stage, dir)
	end

	Dir.mkdir @image

	if @systemBuild and target.profile and tree = target.profile['tree']
		@log.header 'Building distribution tree'

		Dir.chdir @image

		for line in parseList tree
			dir, icon = line.split
			@log.detail dir
			Dir.mkdir dir unless exists? dir

			if icon
				@log.detail 'Setting icon ' + icon
				action "addattrib #{dir} os::Icon " + File.join(@iconsPath, icon)
			end
		end

		Dir.chdir @workDir
	end

	action 'sync'
end

def downloadModule target
	unless
		if locations = (recipe = getRecipe target)['locations']  # Get the source package(s)
			@log.subheader 'Downloading source package(s)'
			Dir.chdir File.join(@configPath, 'downloading')

			for package in ((packages = recipe['packages']) ?
				firstColumn(parseList(packages)) :
				commonName(target)
			)
				unless sourcePackageAvailable? package
					break if for location in toList locations
						break unless for type in ['tar.bz2', 'tbz2', 'tar.gz', 'tgz', 'zip']
							@log.subheader 'Trying ' + f = File.join(location, file = package + '.' + type)
							break if action "wget --tries=5 --passive-ftp '#{f}'"
						end
					end

					@log.subheader "Moving package #{file = File.basename file} to sources directory"
					break unless action "mv #{file} " + @sourcesPath
				end
			end
		else  # Get it from a repository
			(exists? dir = File.dirname(target) or action 'mkdir --parents ' + dir) and
			begin  # We have a destination dir
				Dir.chdir File.dirname(target)  # if target['/']

				@log.subheader 'Checking out sources from CVS repository'
				action "cvs -q checkout -d #{File.basename target} " + File.join(@cvsPath, target)
			end
		end
	then
		@log.failure target
		false
	else
		Dir.chdir @workDir
		action 'sync'
	end
end

def updateModule target
	unless
		unless exists? target
			@log.error 'No source installed; unable to update'
			false
		else
			Dir.chdir target

			if exists? 'CVS'
				@log.subheader 'Updating sources from CVS repository'
				action 'cvs -q update -dP'
			else
				@log.warning 'Unable to update: not a CVS repository'
				true
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def unpackModule target
	unless
		unless exists? dir = File.dirname(target) or action 'mkdir --parents ' + dir
			false
		else  # We have a destination dir
			Dir.chdir File.dirname(target)  # if target['/']
		
			files = []
		
			unless
				for package in (packages = getRecipe(target)['packages']) ?
					parseList(packages) :
					[commonName(target)]
		
					package, dir = package.split
					base = File.join @sourcesPath, File.basename(package)
					option = dir ? ' --directory=' + dir : ''
		
#					file = Dir[File.join(@sourcesPath, fullName target) + '.*'] [0]
#					case File.basename file
		
					if exists? file = base + '.zip'
						type = :zip
						break unless action 'unzip ' + file + (dir ? ' -d ' + dir : '')
					elsif exists? file = base + '.tar.bz2' or exists? file = base + '.tbz2'
						type = :bzip
						break unless action "tar#{option} -xjf " + file
					elsif exists? file = base + '.tar.gz' or exists? file = base + '.tgz'
						type = :gzip
						break unless action "tar#{option} -xzf " + file
					else
						@log.error "Source package #{base}.* not found"
						break
					end
		
					files << [file, type]
					action 'sync'
				end
			then
				false
			else
				if exists? dir = fullName(target)
					true
				else  # Source package content has a deviating subdirectory name
					@log.subheader 'Renaming source'
		
					file, type = files.first
					result = `#{case type
						when :zip  then 'unzip -lqq ' + file
						when :bzip then "bzcat #{file} | tar --list"
						when :gzip then 'tar tzf ' + file
						end
					}`
					unless (status = $? >> 8) == 0
						@log.error status
						false
					else  # Get the directory name from the package listing
						action "mv #{type == :zip ?
							parseList(result).first.split.last :
							result.split.first.split("/").first
						} " + dir
					end
				end
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def patchModule target
	unless
		unless
			(lineage = lineage target).each_with_index {|kin, i|
				ancestor = i < lineage.size - 1

				if exists? file = File.join(recipePath(kin), fullName(kin) + '.patch')
					@log.header 'Applying patch' + (ancestor ? ' from ancestor ' + kin : '')
					break unless action 'patch --strip=1 < ' + file
				end

				if exists? dir = File.join(recipePath(kin), 'patches')
					@log.header 'Overlaying extra source files' + (ancestor ? ' from ancestor ' + kin : '')
					break unless action "cp -a #{File.join dir, '*'} ." and
						# FIXME: crude way to remove possible CVS dirs from patches
						deleteCVSData ''
				end
			}
		then
			false
		else
			unless
				if dirs = (recipe = getRecipe target)['patch-config']
					@log.header 'Patching configuration'
					files = File.join @configPath, 'config/config.*'

					if dirs == ''
						action "cp -a --force #{files} ."
					else
						for dir in toList dirs
							break unless action "cp -a --force #{files} #{dir}/"
						end
					end
				elsif dir = recipe['patch-legacy-config']
					@log.header 'Patching configuration'

					action "cp -a #{File.join @configPath, 'config/legacy/*'} " +
						(dir == '' ? '.' : dir)
				else
					true
				end
			then
				false
			else
				unless
					not cmdLine = recipe['patch'] or
					begin
						@log.header 'Executing patch instructions'
						action toCommand(cmdLine)
					end
				then
					false
				else
					not recipe['make-shared'] or
					begin
						@log.header 'Enabling shared libraries'
						action 'cp /usr/libtool/share/libtool/ltmain.sh .' and
							action 'aclocal -I /usr/libtool/share/aclocal' and
							action 'automake' and
							action 'autoconf'
					end
				end
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def deleteModule target
	unless
		exists? target or
		begin
			@log.header 'Deleting source'
			action 'rm --recursive --force ' + target
		end
	then
		@log.error 'Failed to delete source'
		@log.failure target
		false
	else
		action 'sync'
	end
end

def getModule target
	begin
		exists? target or
		begin
			@log.subheader 'Installing source'

			(sourcePackagesAvailable? target or downloadModule target) and (
				exists? target or  # It was a repository checkout
				unpackModule target  # It was a package download
			) and
			begin
				Dir.chdir @workDir
				Dir.chdir target
				patchModule target
			end
		end
	end or
	begin
		# FIXME: cascading error reporting
		@log.error 'Source not (completely) installed'
		@log.failure target
		false
	end
end

def configureModule staging, target
	Dir.chdir target

	if native? target
		@log.header 'Building dependencies'

		action makeCommand(target) + ' deps'
		# Continue building even if dependencies failed
		action 'sync'
	else
		unless
			if cmdLine = (recipe = getRecipe target)['configure']
				@log.header 'Configuring'
				action toCommand(cmdLine)
			else
				unless exists? cmd = configureCommand(target)
					# Nothing to be done here
					true
				else
					unless exists? dir = buildDir(target) or
						begin
							@log.header 'Creating build directory'
							action 'mkdir ' + dir
						end
					then
						false
					else
						@log.header 'Configuring'

						# Some ports require an absolute path to the configure command
						cmd = File.join(Dir.getwd, cmd)
						Dir.chdir dir
	
						if exists? 'config.cache' and not action 'rm config.cache'
							false
						else
							if cmdLine = recipe['pre-configure'] and not action toCommand(cmdLine)
								false
							else
								action(((vars = recipe['configure-env']) ? toVariables(vars) + ' ' : '') +
									cmd +
									((args = recipe['configure-args']) ?
										' ' + toString(args) :
										((p = recipe['configure-prefix']) ?
											' ' + p[1..-2] :  # FIXME: do some checking
											' --prefix='
										) + prefix(staging, target) +
										(@crossCompile ? " --build=#{@machType} --host=" + @target : '')
									) +
									((options = recipe['configure-options']) ? ' ' + toString(options) : '')
								)
							end
						end
					end
				end
			end
		then
			@log.failure target
			false
		else
			action 'sync'
		end
	end
end

def cleanModule target
	unless
		not exists? dir = buildDir(target) or
		if getRecipe(target)['build-dir']
			Dir.chdir dir
			action makeCommand(target) + ' clean'
		else
			@log.header 'Deleting build directory'
			action 'rm --recursive --force ' + dir
		end
	then
#		@log.failure target
		false
	else
		action 'sync'
	end
end

def makeModule staging, target
	return true if exists? 'image'

	recipe = getRecipe target
	configured = native?(target) || exists?(File.join(sourcePath(target), configureCommand(target)))
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless
		(not (cmdLine = recipe['pre-make']) or action toCommand(cmdLine)) and
		action(if cmdLine = recipe['make']
			toCommand cmdLine
		else
			((vars = recipe['make-env']) ? toVariables(vars) + ' ' : '') +
			makeCommand(target) +
			(configured ?
				'' :
				" #{(var = recipe['install-prefix-var']) ? var : 'prefix'}=" + prefix(staging, target)
			) +
			((vars = recipe['make-vars']) ? ' ' + toVariables(vars) : '') +
			((options = recipe['make-options']) ? ' ' + toString(options) : '') +
			((targets = recipe['make-targets']) ? ' ' + toString(targets) : '')
		end) and
		(not (cmdLine = recipe['post-make']) or action toCommand(cmdLine))
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def testModule target
	return true if exists? 'image'

	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless action makeCommand(target) + ' ' +
		((options = (recipe = getRecipe(target))['test-options']) ? toString(options) + ' ' : '') +
		((targets = recipe['test-targets']) ? toString(targets) : 'check')
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def installModule originalStaging, staging, directive, target
	root = installPath staging, target
	name = shortName target

	unless
		if target =~ /\.(zip|tgz)$/ and exists? target  # A distribution package
			# Packages are currently supposed to contain an unversioned directory
			root = File.join(dir = File.dirname(root), name)

			if exists? root and not
				begin
					@log.header 'Uninstalling ' + name
					uninstallModule staging, target  # FIXME: double failure logging!
				end
			then
				false
			else
				@log.header 'Unpacking ' + target
				action (target[-3..-1] == 'zip' ?
					"unzip '#{target}' -d #{dir}" :
					"tar --directory=#{dir} -xpPzf '#{target}'"
				) and
					registerModule staging, name, root
			end
		else
			if native? target
				Dir.chdir target

				if exists? 'image'  # Command-line resource module without makefile
					if exists? root and not
						begin
							@log.header 'Uninstalling ' + name
							uninstallModule staging, target  # FIXME: double failure logging!
						end
					then
						false
					else
						@log.header 'Installing image files'
						action "mkdir " + root and
							copyFiles 'image', root, '' and
							registerModule staging, target, root
					end
				else
					if exists? dir = buildDir(target) then Dir.chdir dir end

					unless staging
						action makeCommand(target) + ' install'
					else
						unless action makeCommand(target) + ' dist'
							false
						else
#							@log.header 'Installing documentation'
#							if action makeCommand(target) + ' doc'
#								action makeCommand(target) + ' install-doc'
#							end

							true
						end
					end
				end
			else
				recipe = getRecipe target

				if exists? root and not
					begin
						if recipe['merge-install']
							@log.header 'Unregistering ' + name = installName(target)
							action "package unregister #{name} " + @stage + (
								staging == :imaging and @systemBuild ?
								' ' + @indexesRoot :
								''
							)
						elsif staging or not firstColumn(parseList(recipe['install-needs'])).include? name
							@log.header 'Uninstalling ' + name
							uninstallModule staging, target  # FIXME: double failure logging!
						else
							@log.error "Won't uninstall current version because package needs itself to install"
							false
						end
					end
				then
					false
				else
					if dirs = recipe['install-tree']
						@log.header 'Creating subdirectories'
						@log.detail root
						Dir.mkdir root

						for dir in toList dirs
							@log.detail d = File.join(root, dir)
							Dir.mkdir d
						end
					end

					unless exists? target
						true
					else
						@log.header 'Doing the installation'

						superAccess = recipe['super-install'] ? 'sudo ' : ''

						Dir.chdir target
						configured = exists?((cmd = recipe['configure-cmd']) ? toString(cmd) : 'configure')
						if exists? dir = buildDir(target) then Dir.chdir dir end

						if not action(
							if cmdLine = recipe['install']
								toCommand cmdLine
							else
								((vars = recipe['install-env']) ? toVariables(vars) + ' ' : '') +
								superAccess + makeCommand(target) +
								(	staging != :imaging && configured ?
										'' :
										((p = recipe['system-prefix-var']) ?
											" #{p}=" + @systemRoot :
											''
										) +
										" #{(var = recipe['install-prefix-var']) ? var : 'prefix'}=" +
											(p ? prefix(staging, target) : root)
								) +
								((vars = recipe['install-vars']) ? ' ' + toVariables(vars) : '') +
								' ' + ((targets = recipe['install-targets']) ? toString(targets) : 'install')
							end
						)
							false
						elsif cmdLine = recipe['post-install'] and not
							begin
								@log.header 'Executing post-installation commands'
								action toCommand(cmdLine)
							end
						then
							false
						elsif files = recipe['install-files'] and not
							begin
								@log.header 'Installing files'
	
								for line in parseList files
									source, destination = toList line
									break unless action superAccess + "cp -a #{source} " + File.join(root, destination)
								end
							end
						then
							false
						else
							Dir.chdir root

							if exists? 'share/man' and not exists? 'man' and not
								begin
									@log.header 'Moving man directory to standard location'
									action superAccess + 'mv share/man .'
								end && (
									not empty? 'share' or
									begin
										@log.header 'Deleting empty share directory'
										action superAccess + 'rm --recursive --force share'
									end
								)
							then
								false
							elsif exists? 'share/info' and not exists? 'info' and not
								begin
									@log.header 'Moving info directory to standard location'
									action superAccess + 'mv share/info .'
								end && (
									not empty? 'share' or
									begin
										@log.header 'Deleting empty share directory'
										action superAccess + 'rm --recursive --force share'
									end
								)
							then
								false
							elsif files = recipe['move-files'] and not
								begin
									@log.header 'Moving files'

									for line in parseList files
										source, destination = toList line
										break unless action superAccess + "mv #{source} " + (
											destination[0, 1] == '/' && staging == :imaging ?
												File.join(@systemImage, destination) :
												destination
										)
									end
								end
							then
								false
							elsif files = recipe['delete-files'] and not
								begin
									@log.header 'Deleting files from installation'
									action superAccess + 'rm --recursive --force ' + toString(files)
								end
							then
								false
							else
								(docs = "#{toString recipe['documentation']} #{toString recipe['develop-docs']}") == ' ' or
								begin
									@log.header 'Installing documentation'
									Dir.chdir @workDir
									Dir.chdir target
									action superAccess + "cp -a #{docs} " + root
								end
							end
						end
					end and
					if exists? filesPath = File.join(@portsPath, fullName(target), 'distro') and not
						begin
							@log.header 'Installing extra files'
							copyFiles filesPath, root, superAccess
						end
					then
						false
					elsif links = recipe['links'] and links != '' and not
						begin
							@log.header 'Creating links'

							for link in parseList links
								original, destination = toList link
								linkPath = File.dirname destination
								linkFile = File.basename destination

								if linkPath[0, 1] == '/'  # A link into the system
									next if staging == :staging

									original = File.join prefix(staging, target), original if original['/']

									if staging == :imaging
										linkPath = File.join @systemRoot,
											linkPath[0, 4] == '/usr' ?
												'' :
												'system',  # A link into the core system
											linkPath
									end
								else  # A link within the package
									linkPath = File.join root, linkPath
								end

								break unless action superAccess + "cd #{linkPath} && ln -sf #{original} " + linkFile
							end
						end
					then
						false
					elsif not @settings['no-strip'] || recipe['no-strip'] || (
							(dirs = ['bin', 'sbin', 'libexec'].collect {|dir|
								exists?(dir = File.join(root, dir)) ? dir : nil
							}.compact).empty? ||
							begin
								@log.header 'Stripping executables'
								#--strip-unneeded
								action superAccess + 'strip --strip-all' + dirs.collect {|dir| ' ' + File.join(dir, '*')}.join or
									$? >> 8 == 1  # File type not recognized
							end and
							! exists?(dir = File.join(root, 'lib')) ||
							begin
								@log.header 'Stripping libraries'
								action superAccess + 'strip --strip-debug ' + File.join(dir, '*') or $? >> 8 == 1
							end
						)
					then
						false
					elsif (originalStaging == :imaging and @systemBuild or not originalStaging) and
							['system', 'libraries'].include? directive and not
						begin
							@log.header 'Moving shared libraries into system'

							for libs in ['*.so', '*.so.*']
								break unless action superAccess + "mv #{File.join(root, 'lib', libs)} " +
									File.join(originalStaging ? @systemRoot : '/',
										'system/libs/'
									)
							end
						end
					then
						false
					else
						registerModule staging, target, root
					end
				end
			end
		end
	then
		@log.failure target
	else
		action 'sync'
	end
end

def registerModule staging, target, root
	@log.header 'Registering ' + target

	if staging
		registerPort staging, target and (  # @bootstrap or (
			not exists? dir = File.join(root, 'init') or
			for file in listFiles dir
				# FIXME: break unless action 'source ' + file
			end
		)  # )
	else
		action 'pkgmanager --add ' + root
	end
end

def uninstallModule staging, target
	unless
		if dir? target and native? target and not exists? File.join(target, 'image')
		then  # A native non-resource module
			Dir.chdir target
			if exists? dir = buildDir(target) then Dir.chdir dir end

			action makeCommand(target) + ' uninstall'
		else
			dir = installPath staging, target
			name = shortName target

			unless staging or  # FIXME: no unregistering when staging
				begin
					@log.header 'Unregistering ' + name
					action 'pkgmanager --remove ' + dir
				end
			then
				false
			else
				@log.header 'Deleting ' + name
				action 'rm --recursive --force ' + dir
			end
		end
	then
		@log.failure target
		false
	else
		action 'sync'
	end
end

def buildPackage target
	file = (name = fullName target) + '.bin.1.zip'

	unless
		if exists? file and not action 'rm ' + file
			# Zip would add to the existing package
			@log.error "Couldn't remove existing package " + file
			false
		else
			Dir.chdir root = installRoot(false)

#			action 'tar -cvzf ' + file +
#				" --directory=#{root} " +
			action 'zip -ry' +
#				' -b ' + dereference(root) +  # Doesn't work
				" #{File.join @workDir, file} " +
					installName(name)
#				Doesn't work with Zip:
#				(	(links = (links = parseList(getRecipe(name)['links'])) ?
#						links.collect { |link|
#							(destination = toList(link)[1])[0, 1] == '/' ?  # A link into the system
#								destination :
#								nil
#						}.compact :
#						[]
#					) == [] ?
#						'' :
##						' --absolute-names ' + toString(links)
#						' ' + toString(links)
#				)
		end
	then
		@log.failure target
	else
		action 'sync'
	end
end

def registerPort staging, target  # Create symlinks for a ported package
#	@log.header 'Registering ' + target

	unless
		for subdir in ['etc', 'bin', 'sbin', 'info', 'early-init', 'init']  # Flat directories
			break unless linkSubdir staging, target, subdir, false
		end and
		for subdir in ['lib', 'libexec', 'include', 'share'] << 'man'  # Nested directories
			break unless linkSubdir staging, target, subdir, true
		end
	then
#		@log.failure target
		false
	else
		action 'sync'
	end
end

def linkSubdir staging, target, subdir, nesting
	not exists? dir = File.join(installPath(staging, target), subdir) or
	begin
		@log.detail subdir
		Dir.chdir dir

		Dir[nesting ? '**/*' : '*'].each do |node|
			break unless
				linkNode subdir, node,  # Link node into the staging area
					File.join(dir, node),
					File.join(@stage, subdir, node) and
				(staging != :imaging or ! @systemBuild or
					linkNode subdir, node,  # Link node into the system image
						File.join(installPath(false, target), subdir, node),
						File.join(@indexesRoot, subdir, node)
				)
		end
	end
end

def linkNode subdir, node, source, destination
	if dir? node
		dir? destination or action 'mkdir ' + destination
	elsif symlink? destination
		if subdir == 'info' and node == 'dir'
			@log.warning 'info/dir file not registered due to pre-existing file'
		else
			@log.error "Conflict: link #{destination} already exists!"
			# For practical purposes, don't consider this fatal
		end
		true
	else
		File.symlink source, destination
	end
end

def buildModule staging, directive, target
	if getModule target  # Source is available
		Dir.chdir @workDir  # Target path may be relative or absolute

		@log.header 'Cleaning'
		Dir.chdir target
		cleanModule target
		Dir.chdir @workDir

		if configureModule(effectiveStaging = ['stage', 'libraries'].include?(directive) ?
				:staging :
				staging,
			target
		)
			@log.header 'Making'

			if makeModule(effectiveStaging, target) and effectiveStaging
				Dir.chdir @workDir

				@log.header 'Installing in staging area'
				installModule staging, effectiveStaging, directive, target
			end
		end
	end

	Dir.chdir @workDir
end

def prepareModule target
	@log.entry target

	if warnings = getRecipe(target)['warnings']
		@log.warning warnings
	end

	for line in parseList @settings[native?(target) ? 'native-env' : 'ports-env']
		var, value = toKeyValue line
		ENV[var] = value
	end

	for var in ['CFLAGS', 'CXXFLAGS', 'IMAGE']
		@log.extra var + ': ' + ((value = ENV[var]) ? value : '')
	end
end


# Functions for multiple modules

def get targets
	@log.header 'Fetching ' + targets.to_s

	for target in targets.modules
		prepareModule target
		getModule target
		Dir.chdir @workDir
	end
end

def download targets
	@log.header 'Downloading ' + targets.to_s

	for target in targets.modules
		prepareModule target
		downloadModule target
		Dir.chdir @workDir
	end
end

def update targets
	@log.header 'Updating ' + targets.to_s

	for target in targets.modules
		prepareModule target
		updateModule target
		Dir.chdir @workDir
	end
end

def unpack targets
	@log.header 'Unpacking ' + targets.to_s

	for target in targets.modules
		prepareModule target
		unpackModule target
		Dir.chdir @workDir
	end
end

def patch targets
	@log.header 'Patching ' + targets.to_s

	for target in targets.modules
		prepareModule target

		Dir.chdir target
		unless patchModule target
			@log.error 'Source not patched'
			@log.failure targets.to_s
		end
		Dir.chdir @workDir
	end
end

def delete targets
	@log.header 'Deleting ' + targets.to_s

	for target in targets.modules
		prepareModule target
		deleteModule target
	end
end

def distclean targets
	@log.header 'Cleaning distribution ' + targets.to_s

	for target in targets.modules
		prepareModule target

		Dir.chdir target
		action makeCommand(target) + ' distclean', target
		Dir.chdir @workDir
	end
end

def configure targets
	@log.header 'Configuring ' + targets.to_s

	for target in targets.specs
		prepareModule target

		directive = false
		directive, target = target.split if target[' ']

		configureModule ['stage', 'libraries'].include?(directive) ? :staging : false, target
		Dir.chdir @workDir
	end
end

def clean targets
	@log.header 'Cleaning ' + targets.to_s

	for target in targets.modules
		prepareModule target

		Dir.chdir target
		cleanModule target
		Dir.chdir @workDir
	end
end

def make targets
	@log.header 'Making ' + targets.to_s

	for target in targets.modules
		prepareModule target

		directive = false
		directive, target = target.split if target[' ']

		Dir.chdir target
		makeModule ['stage', 'libraries'].include?(directive) ? :staging : false, target
		Dir.chdir @workDir
	end
end

def test targets
	@log.header 'Testing ' + targets.to_s

	for target in targets.modules
		prepareModule target

		Dir.chdir target
		testModule target
		Dir.chdir @workDir
	end
end

def install targets
	@log.header 'Installing ' + targets.to_s

	for target in targets.modules
		prepareModule target

		installModule false, false, false, target
		Dir.chdir @workDir
	end
end

def uninstall targets
	@log.header 'Uninstalling ' + targets.to_s

	for target in targets.modules
		prepareModule target

		uninstallModule false, target
		Dir.chdir @workDir
	end
end

def buildPackages targets
	@log.header 'Making distribution packages ' + targets.to_s

	for target in targets.modules
		prepareModule target

		buildPackage target
		Dir.chdir @workDir
	end
end

def buildPack targets
	@log.header 'Making compound package ' + name = targets.to_s

	unless
		unless (profile = targets.profile) and exists? imageDir = File.join(@portsPath, name, 'distro')
			@log.error 'Not a valid compound package'
			false
		else
			if n = profile['name'] then name = n end

			action "mkdir " + name and
			begin
				action "cp -a #{File.join imageDir, '*'} " + name and
				begin
					Dir.chdir name
			
					deleteCVSData '' and
					begin
						Dir.chdir @workDir
			
						for package in modules = targets.modules
							# Try to find the latest release. FIXME: alphabetical ordering
							break unless action "ln -s #{Dir[
									File.join(@distrosPath, fullName(package)) + '.bin.*.*z*'
								].last
							} " + name
						end and
						begin
#							action "tar --dereference --remove-files -cvzf #{name}.bin.1.tgz " + name
							action "zip -rm #{name}.bin.1.zip " + name
#								toString(modules.collect {|package| installName package})
						end
					end
				end
			end
		end
	then
		@log.failure name
	else
		action 'sync'
	end
end

def build staging, targets
	@log.header 'Building ' + targets.to_s

	if staging == :imaging and @systemBuild and targets.profile and resources = targets.profile['resources']
		@log.header 'Installing resources'

		Dir.chdir @image

		for line in parseList resources
			dir, resource, type = line.split
			files = File.join @resourcesPath, resource
			@log.detail resource

			unless
				if Dir[files] == []  # Not single files; look for a pack
					action "unzip -o #{files}.zip -d " + dir
				else
					action "cp -a #{files} " + dir and (
						not type or
						begin
							@log.detail 'Setting type ' + type
							action "addattrib #{File.join dir, File.basename(files)} os::MimeType " + type
						end
					)
				end
			then
				@log.failure targets.to_s
				return
			end
		end

		Dir.chdir @workDir
		action 'sync'
	end

	# Build all directories

	for target in targets.specs
		prepareModule target

		directive = false
		directive, target = target.split if target[' ']

		buildModule staging, directive, target
	end
end


# Helper functions

def deleteCVSData superAccess  # TODO: implement super user execution
	puts "\nWARNING! If this is a CVS repository, it will be clobbered!"

	# Delete all CVS dirs
	# (They would trigger some ports to reconfigure themselves.)
	@log.header 'Cleaning out CVS directories'

	Dir['**/CVS'].each do |dir|
		@log.detail dir

		# Delete all files in the CVS dir first
		for file in listFiles dir
			File.delete file
		end

		Dir.delete dir
	end

	@log.header 'Cleaning out .cvsignore files'

	Dir['**/.cvsignore'].each do |file|
		@log.detail file
		File.delete file
	end
end

def exists? file
	FileTest.exists? file
end

def file? file
	FileTest.file? file
end

def dir? file
	FileTest.directory? file
end

def symlink? file
	FileTest.symlink? file
end

def empty? dir
	Dir[File.join(dir, '*')] == []
end

def listFiles dir
	Dir.entries(dir).collect {|file| File.join dir, file}.delete_if {|file| not file? file}
end

def dereference file
	symlink?(file) ?
		(file[0, 1] == '/' ?
			('/' + dereference(File.readlink(file))) :
			dereference(File.readlink(file))
		) :
		file
end

def copyFiles sourceDir, destinationDir, superAccess
	action superAccess + "cp -a #{File.join sourceDir, '*'} " + destinationDir and
	begin
		# FIXME: crude way to remove possible CVS dirs from files
		Dir.chdir destinationDir
		deleteCVSData superAccess
	end
end

def loadFile file  # Load the lines of a file into an array, discarding comments and empty lines
	lines = []

	File.open file do |file|
		file.each do |line|
			# Get rid of record delimiter, comments and empty lines
			lines += [line.chomp] unless line.strip == '' or line[0, 1] == ';'
		end
	end

	lines
end

def saveFile data, file  # Write an array to a text file
	File.open file, 'w' do |file|
		for line in data
			file << line + "\n"
		end
	end
end

def parseMap text  # Load key/value pairs into a hash table
	hash = {}

	for line in text
		if line !~ /^\s+/  # A key line
			unless (line = line.strip)[/\s/]  # A single key
				hash[lastKey = line] = ''
			else  # A key with a value
				lastKey, value = toKeyValue line
				hash[lastKey] = value
			end
		else  # Starts with whitespace, so it's a list value
			if hash[lastKey] == ''
				hash[lastKey] = [line.strip]
#				margin = $&
			else
				hash[lastKey] << line.strip
			end
		end
	end

	hash
end

def parseList value  # Normalize value into an array
	if value.is_a? String
		value.split "\n"
	else  # Assume it's already an array, or nil
		value
	end
end

def toKeyValue line
	i = line.index(/\s/)  # First whitespace
	[line[0, i], line[i + 1 .. line.length - 1].strip]
end

def toList value  # Force values into an array
	if value.is_a? String
		if value == ''
			[]
		else
			value.split
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def toString value  # Join list value into a space-separated string
	if value.is_a? Array
		value.join(' ')
	else  # Assume it's already a string, or nil
		value
	end
end

def toCommand value  # Join list value into a semicolon-separated shell command string
	if value.is_a? Array
		value.join(' && ')
	else  # Assume it's already a string, or nil
		value
	end
end

def toVariables value  # Join an array of environment variables into shell syntax
	toString((parseList value).collect do |line|
		var, value = toKeyValue line
		var + '=' + value
	end)
end

def firstColumn list  # Extract the first value of each line from a list of unsplit lines
	list ? list.collect {|line| line.split.first} : []
end

def fullName port
	# Extract name including version and flavor, if necessary
	File.basename port[-1, 1] == '/' ? port.chop : port
end

def commonName port
	# Extract name without flavor
	name = /.+-(\d.*|)-|.+(-\d.*$|\.|$)/.match(fullName(port)).to_s
	/(--|-|\.|)$/.match(name).pre_match
end

def shortName port
	# Extract name without version
	/--|-\d|\.|$/.match(fullName(port)).pre_match
end

def installName port
	port = fullName port
	@includeVersion && ! @systemBuild ?
		port :
		shortName(port)
end

def sourcePath target
	target[0, 1] == '/' ? target : File.join(@workDir, target)
end

def buildDir target
	(dir = getRecipe(target)['build-dir']) ? dir : '../_' + fullName(target)
end

def prefix staging, port
	File.join staging == :staging ? @stage : '/usr', installName(port)
end

def installRoot staging
	case staging
	when :staging
		@stage
	when :imaging
		@systemBuild ? File.join(@systemRoot, 'usr') : @image
	else
		'/usr'
	end
end

def installPath staging, port
	File.join installRoot(staging), installName(port)
end

def recipePath portPath
	File.join @portsPath, portPath
end

def native? target
	not exists? File.join(sourcePath(target), 'configure') and not
		# Currently look for a recipe to distinguish from meta-packages:
		getRecipe(target)['authors']
end

class Profile
attr_reader :profile

	def Profile.path= path
		@@profilesPath = path
	end

	def initialize target
		@profile = exists?(@file = File.join(@@profilesPath, target)) ?
			parseMap(loadFile(@file)) :
			nil
	end

	def [] key
		(value = @profile[key]) ?
			value :
		exists?(file = File.join(@file, key)) ?
			loadFile(file) :
			nil
	end

	def []= key, value
		saveFile [key] + (value ? value.collect {|line| "\t" + line} : []), @file  # File.join(@file, key)
	end
end

def getTarget target
	profile = nil
	Struct.new(:to_s, :specs, :modules, :profile).new(
		target,
		# Get the list of modules for the build target, or a single module
		specs = if target['/']  # A single target directory
			target[-1, 1] == '/' ? target.chop : target
		elsif (p = Profile.new target).profile  # A profile
			(l = toList((profile = p)['modules'])) ? l : []
		else
			target
		end,
		specs.collect {|line| line.split.last},
		profile
	)
end

def loadRecipe project, target  # Read a recipe file
	if exists? file = File.join(recipePath(File.join(project, target = fullName(target))), target + '.recipe')
		loadFile file
	else  # No recipe
		[]
	end
end

def overlayRecipe recipe, overlay
	for key, value in overlay
		recipe[key] = value
	end
	recipe
end

def getRecipe target  # Load the key/value pairs of a recipe into a hash table
	target = fullName target
	recipe = {}
	ancestry = []

	for project in @lineage
		if (projectRecipe = parseMap loadRecipe(project, target)) != []
			recipe = overlayRecipe(recipe, projectRecipe)
			ancestry.push File.join(project, target)
		end
	end

	if parents = recipe['inherits']
		ancestorsRecipe = {}
		parentAncestries = []

		for parent in toList parents
			ancestorsRecipe = overlayRecipe(ancestorsRecipe, parentRecipe = getRecipe(parent))
			parentAncestries.push parentRecipe['ancestry']
		end

		recipe = overlayRecipe(ancestorsRecipe, recipe)
		recipe['ancestry'] = [parentAncestries] << ancestry
	else
		recipe['ancestry'] = ancestry
	end

	recipe
end

def lineage target
	getRecipe(target)['ancestry'].flatten
end

def configureCommand port
	(cmd = getRecipe(port)['configure-cmd']) ? toString(cmd) : 'configure'
end

def makeCommand port
	'make' + ((file = getRecipe(port)['makefile']) ? ' -f ' + file : '')
end

def sourcePackageAvailable? package
	Dir[File.join(@sourcesPath, File.basename(package) + '.*')] != []
end

def sourcePackagesAvailable? target
	for package in ((packages = getRecipe(target)['packages']) ?
		firstColumn(parseList(packages)) :
		commonName(target)
	)
		break unless sourcePackageAvailable? package
	end
end

def action command  # Return the output of the shell command, or false if unsuccessful
	@log.action command
	stdout = `#{command}`
	if (status = $? >> 8) == 0  # OK
		@log.result stdout
		stdout
	else
		@log.error status
		@log.result stdout
		false
	end
end

class Log
attr_reader :failures

	def Log.path= path
		Dir.mkdir path unless exists? path

		@@logsPath = path
	end

	def Log.[] log
		IO.readlines File.join(@@logsPath, log)
	end

	def initialize machType, crossCompile
		@failures = []

		@log		= File.new File.join(@@logsPath, 'stdout'), 'w'
		@summary	= File.new File.join(@@logsPath, 'summary'), 'w'
		@failLog	= File.new File.join(@@logsPath, 'failures'), 'w'

		@log << s = (crossCompile ? 'Cross-b' : 'B') + "uilding in root directory #{Dir.getwd} on #{machType}\n"
		@summary << s
		@failLog << s
	end

	def close
		@log << s = "\nFinished\n"
		@summary << s

		@log.close
		@summary.close
		@failLog.close
	end

	def header header
		print "\n" + s = header + "\n"
		@log << "\n#{s}\n"
		@summary << s
	end

	def subheader header
		print "\n" + s = header + "\n"
		@log << "\n#{s}\n"
		@summary << s
	end

	def entry entry
		print s = "\n#{entry}\n"
		@log << s
		@summary << s
	end

	def detail detail
		puts detail
		@log << detail + "\n"
	end

	def extra extra
		@log << "\n#{extra}\n"
	end

	def action action
		puts "\n#{action}\n"
		@log << action + ': '
		@summary << action
	end

	def warning warnings
		unless warnings.is_a? Array
			puts "\n" + s = 'Warning: ' + warnings
			@log << s + ':'
			@summary << ": #{s}\n"
		else
			puts "\n" + s = "Warnings:\n"
			@log << s
			@summary << s

			for line in warnings
				puts line
				@log << line + "\n"
				@summary << line + "\n"
			end
		end
	end

	def error error
		puts "\n" + s = "Error: #{error}"
		@log << s + ':'
		@summary << ": #{s}\n"
	end

	def result result
		@log << "\n\n" << result
		@summary << "\n"
	end

	def failure target
		@failLog << target + "\n"
		@failures << target
	end
end


# Define paths

@workDir = Dir.getwd

# Get the path to the application directory.
@builderPath = File.dirname File.dirname(dereference(File.expand_path($0)))

# Get global settings
@settings = parseMap loadFile(File.join(@builderPath, 'settings'))

@portsPath, Profile.path,	@configPath,	@resourcesPath,	@distrosPath,		Log.path = [
'packages', 'profiles',		'sources',		'resources',	'distributions',	'logs'
].collect {|dir| File.join @builderPath, dir}

@sourcesPath = (dir = @settings['sources-path']) ? dir : @configPath

@iconsPath = '/system/icons'


# Set environment variables

for line in parseList @settings['environment']
	var, value = toKeyValue line
	ENV[var] = value
end

# Define settings

# BASh 3 only exports the $SYSTEM variable:
@syllable = `uname`.chomp == 'syllable'
@machType = "#{`uname -m`.chomp}-#{
		(hardware = `uname -i`.chomp) == 'unknown' and @syllable ? 'pc' : hardware
	}-#{`uname -s`.chomp}"

# Project trees
@lineage = (@lineage = @settings['lineage']) ?
	parseList(@lineage) :
	['']

# Confine ourselves to a subsection of CVS?
@cvsPath = '' unless @cvsPath = @settings['cvs-path']

# Include version number on installed ports?
@includeVersion = @settings['include-version']

@image = File.join(@stage = File.join(@workDir, 'stage'), 'image')

@indexesRoot = File.join @image, 'atheos/autolnk'

unless @systemBuild = File.basename(@workDir) == 'system'
	@crossCompile = false
	@systemRoot = '/'
	@systemImage = '/boot'
else
	if @crossCompile = @target = @settings['target']
		ENV['CC']  = @target + '-gcc'
		ENV['CXX'] = @target + '-g++'
		ENV['AS']  = @target + '-as'
		ENV['LD']  = @target + '-gcc'
		ENV['CFLAGS']   = "-b #{@target} " + (var = ENV['CFLAGS']   ? var : '')
		ENV['CXXFLAGS'] = "-b #{@target} " + (var = ENV['CXXFLAGS'] ? var : '')
		ENV['LDFLAGS']  = "-b #{@target} " + (var = ENV['LDFLAGS']  ? var : '')
	end

	@systemImage = @image
	@systemRoot = File.join @systemImage, 'atheos'

#	@buildTools = File.join @workDir, 'build-tools'

#	ENV['DIST_VER'] = '0.6.2+'
#	ENV['DIST_NAME'] = 'base-syllable-0.6.2+.zip'

	ENV['ATHEOS_SRC'] = @workDir
#	ENV['BUILD_TOOLS'] = File.join @workDir, 'build-tools'
	ENV['DIST_DIR'] = @image
end

ENV['IMAGE'] = @systemRoot

# Isolate build in staging area from the build host?
@isolateStage = @crossCompile || @settings['isolate-stage']
# Or run newly built binaries and libraries on the build host to bootstrap?
@bootstrap = !@crossCompile && @settings['bootstrap']


# Main function

arg1, arg2, arg3 = ARGV

case arg1
when 'version', '-v', '--version'
	puts 'Syllable Build System 0.6.120',
		'Copyright (c) 2002-2007 Kaj de Vos',
		'License: GPL 2 or any later version'
when 'help', '?', '-?', '-h', '-help', '--help'
	puts 'Usage:',
		'  build [<command>] [<module> | <profile> | <package> | <log>]',
		'  stage [<module> | <profile> | <package>]',
		'  image [<module> | <profile> | <package>]',
		'<command>:',
		'  help,         Show this help information',
		'    -h, --help,',
		'    -help, -?, (?)',
		'  version,      Show version information',
		'    -v, --version',
		'  scrub         Delete CVS control files recursively from the current directory',
		'  prepare       Initialize project image tree in staging area',
		'  get           Fetch and patch sources',
		'  download      Download sources',
		'  update        Update sources, or the build system itself, from repositories',
		'  unpack        Unpack sources from source packages',
		'  patch         Patch sources',
		'  delete        Delete sources',
		'  distclean',
		'  clean',
		'  configure',
		'  make',
		'  test',
		'  install       (Run as super user)',
		'  uninstall     (Run as super user)',
#		'  register      (Run as super user)',
#		'  activate/elect   (Run as super user)',
#		'  unregister    (Run as super user)',
		'  stage         Build and install in the staging area',
		'  image         Build and install in the image area',
		'  package       Build distribution package',
		'  pack          Build a compound package',
#		'  release       ',
		'  modules       List the modules of a profile',
		'  recipe        List a recipe',
		'  log           Show the last log',
		'<module>:       Module subdirectory',
		'<profile>:      Profile name',
		'  last          Last used profile',
		'  failures      Profile for last failures',
		'<package>:      Distribution package (install command only)',
		'<log>:          Log name',
		'  summary       Summarized log',
		'  failures      Log of failed modules'
when 'modules' then puts Profile.new(arg2)['modules']
when 'recipe'  then puts getRecipe(arg2).to_a
when 'log'     then print Log[arg2 ? arg2 : 'stdout']
else
	@log = Log.new @machType, @crossCompile

	if arg1 == 'scrub'
		deleteCVSData ''
	elsif arg1 == 'update' and not arg2
		@log.header 'Updating build system'

		Dir.chdir @builderPath
		action 'cvs -q update -dP'
	else
		target  = getTarget arg2 ? arg2 : arg1 ? arg1 : './'
		profile = target.profile

		Profile.new('last')['modules'] = profile['modules'] if profile  # Processing a profile

		if arg1 == 'prepare'
			prepare target
		else
			case arg1
			when 'download'		then download		target
			when 'update'		then update			target
			when 'unpack'		then unpack			target
			when 'delete'		then delete			target
			when 'uninstall'	then uninstall		target
			when 'package'		then buildPackages	target
			when 'pack'			then buildPack		target
			else
				for var in ['CC', 'CXX', 'AS', 'LD']
					@log.extra var + ': ' + ((value = ENV[var]) ? value : '')
				end

				# Pick up executables from the staging area

				if @bootstrap then ENV['PATH'] =
						if @systemBuild
							(File.join @image, 'atheos/system/bin') + ':'
#							Executables may not be position-independent:
#							(File.join @image, 'atheos/usr/glibc/sbin') + ':' +
#							(File.join @image, 'atheos/usr/glibc/bin') + ':'
						else
							''
						end +

						(File.join @stage, 'sbin') +
						':' + (File.join @stage, 'bin') +

						':' + ENV['PATH']

					@log.extra 'PATH: ' + ENV['PATH']
				end

				# Pick up headers from the staging area and system repository

				headers =
					if @systemBuild
						# Syllable system headers
						(File.join @image, 'atheos/system/include') + ':' +
						# Linux system and C library headers
						(File.join @image, 'atheos/usr/include') + ':' +
						# C library headers
#						(File.join @image, 'atheos/usr/glibc/include') + ':' +
						(@syllable ? File.join(@workDir, 'sys/include') + ':' : '')
					else
						''
					end +

					# Linked headers
					(File.join @stage, 'include')

				ENV['ATHEOS_INCLUDE_PATH'] = File.join @workDir, 'sys/include' if @systemBuild
				ENV['C_INCLUDE_PATH'] = headers +
					((var = ENV['C_INCLUDE_PATH']) && !@isolateStage ? ':' + var : '')
				ENV['CPLUS_INCLUDE_PATH'] = headers +
					((var = ENV['CPLUS_INCLUDE_PATH']) && !@isolateStage ? ':' + var : '')

				@log.extra 'C_INCLUDE_PATH: ' + ENV['C_INCLUDE_PATH']
				@log.extra 'CPLUS_INCLUDE_PATH: ' + ENV['CPLUS_INCLUDE_PATH']

				# Pick up libraries from the staging area

				ENV['ATHEOS_LIB_PATH'] = File.join @image, 'atheos/system/libs' if @systemBuild

				if @bootstrap then ENV['DLL_PATH'] =
						if @systemBuild
							(File.join @image, 'atheos/system/libs') + ':' +
							(File.join @image, 'atheos/system') + ':'
						else
							''
						end +

						(File.join @stage, 'lib') +
						((var = ENV['DLL_PATH']) ? ':' + var : '')

					@log.extra 'DLL_PATH: ' + ENV['DLL_PATH']
				end

				ENV[name = (@syllable ? '' : 'LD_') + 'LIBRARY_PATH'] =
					if @systemBuild
						(File.join @image, 'atheos/system/libs') + ':' +
						(@syllable ? '' : File.join(@image, 'atheos/system') + ':')
#						(File.join @image, 'atheos/usr/glibc/lib') + ':'
					else
						''
					end +

					(libs = File.join @stage, 'lib') +

					((var = ENV[name]) && !@isolateStage ? ':' + var : '')

				@log.extra name + ': ' + ENV[name]

				# At least Ubuntu doesn't respond to $LD_LIBRARY_PATH. Sigh...
				ENV['LDFLAGS'] = ((var = ENV['LDFLAGS']) ? var + ' ' : '') + '-L' + libs unless @syllable

				@log.extra 'LDFLAGS: ' + ((var = ENV['LDFLAGS']) ? var : '')

				case arg1
				when 'get'			then get		target
				when 'patch'		then patch		target
				when 'distclean'	then distclean	target
				when 'clean'		then clean		target
				when 'configure'	then configure	target
				when 'make'			then make		target
				when 'test'			then test		target
				when 'install'
					ENV['IMAGE'] = '/'
					install target
				when 'stage'
					build :staging, target if exists? @stage or prepare target
				when 'image'
					build :imaging, target if exists? @stage or prepare target
				else
					if arg2
						@log.error 'Unrecognized command'
						exit 1
					else
						build false, target
					end
				end
			end

			Profile.new('failures')['modules'] = @log.failures if profile  # Processing a profile
		end
	end

	action 'sync'
	@log.close
	exit @log.failures.length  # FIXME: only works when processing a profile
end
