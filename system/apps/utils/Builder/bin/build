#! ruby

# Syllable Build System
# Version 0.4.4
# Copyright (c) 2002-2004 Kaj de Vos
# License: GPL 2


# Set environment variables

ENV['CFLAGS']	= "-march=i586 -O2 -pipe"
ENV['CXXFLAGS']	= "-march=i586 -O2 -pipe"

# Define paths

@workDir		= Dir.getwd

@builderPath	= File.dirname(File.dirname(FileTest.symlink?($0) ?
	File.readlink($0) :
	$0
))
@packagesPath	= File.join @builderPath, "packages"
@profilesPath	= File.join @builderPath, "profiles"
@sourcesPath	= File.join @builderPath, "sources"
@distrosPath	= File.join @builderPath, "distros"
@logsPath		= File.join @builderPath, "logs"

# Define settings

# Include version number on installed packages?
@includeVersion = false
#@includeVersion = true

unless @systemBuild = File.basename(@workDir) == "system"
	@installRoot = "/usr"
else
	@distroRoot = File.join @workDir, "dist-root"
#	@buildTools = File.join @workDir, "build-tools"

	@installRoot = File.join(@distroRoot, "atheos/usr")

	ENV['DIST_VER']  = "0.5.2+"
	ENV['DIST_NAME'] = "base-syllable-0.5.2+.tgz"

	ENV['ATHEOS_SRC']			= @workDir
	ENV['ATHEOS_INCLUDE_PATH']	= File.join @workDir, "sys/include"
	ENV['ATHEOS_LIB_PATH']		= File.join @workDir, "libs"
	ENV['BUILD_TOOLS']			= File.join @workDir, "build-tools"
	ENV['DIST_DIR']				= @distroRoot
end


# Functions for single packages

def unpackPackage target
	Dir.chdir File.dirname(target) if target["/"]

	base = File.join @sourcesPath, ((pack = getRecipe(target)["packages"]) ?
		pack :
		fullName(target)
	)
#	file = Dir[File.join(@sourcesPath, fullName target) + ".*"] [0]
#	case File.basename file
	unless
		if exists? file = base + ".tar.bz2" or exists? file = base + ".tbz2"
			gzip = false
			action "bzcat #{file} | tar x"
		elsif exists? file = base + ".tar.gz" or exists? file = base + ".tgz"
			gzip = true
			action "tar xzf " + file
		else
			logError "Source package #{base}.* not found"
			false
		end
	then
		false
	else
		if exists? dir = fullName(target)
			true
		else  # Tarball content has a deviating name
			logSubheader "Renaming source"

			unless result = action(gzip ? "tar tzf " + file : "bzcat #{file} | tar t")
				false
			else
				action "mv #{File.dirname result.split[0]} " + dir
			end
		end
	end
end

def patchPackage target
	if exists? file = File.join(recipePath(target), fullName(target) + ".patch")
		logHeader "Applying delta"
		return false unless action "patch --strip=1 < " + file
	end

	if exists? dir = patchesPath(target)
		logHeader "Applying patches"
		return false unless action "cp -a #{File.join dir, "*"} ."
	end

	if cmdLine = (recipe = getRecipe target)["patch"]
		logHeader "Executing patch instructions"
		return false unless action toString(cmdLine)
	end

	if dirs = recipe["patch-config"]
		logHeader "Patching configuration"
		files = File.join @sourcesPath, "config/config.*"

		if dirs == ""
			action "cp -a #{files} ."
		else
			for dir in toList dirs
				action "cp -a #{files} #{dir}/"
			end
		end
	elsif dir = recipe["patch-legacy-config"]
		logHeader "Patching configuration"
		action "cp -a #{File.join @sourcesPath, "config/legacy/*"} " +
			(dir == "" ? "." : dir)
	else
		true
	end
end

def getPackage target
	unless
		unless exists? target
			logHeader "Installing source"

			unless exists? dir = File.dirname(target) or action "mkdir --parents " + dir
				false
			else  # We have a destination dir
				unless unpackPackage target
					false
				else
					Dir.chdir @workDir
					Dir.chdir target

					patchPackage target
				end
			end
		else
			unless exists? File.join(target, "CVS")
				# Source already prepared
				true
			else
				if Dir[File.join(@sourcesPath, fullName(target) + ".t*")] != []  # Some tarball
					puts "\nWARNING! This will clobber your CVS repository!"
					logHeader "Replacing source"

					unless action "rm -r " + target
						logError "Failed to delete source"
						false
					else
						unless unpackPackage target
							false
						else
							Dir.chdir @workDir
							Dir.chdir target

							patchPackage target
						end
					end
				else
					Dir.chdir target
					unless thirdParty?
						true
					else
						puts "\nWARNING! This will clobber your CVS repository!"
						deleteCVSData
						patchPackage target
					end
				end
			end
		end
	then
		logError "Source not installed"
		logFailure target
		false
	else
		action "sync"
	end
end

def configurePackage target
	unless thirdParty?
		logHeader "Building dependencies"
		action "make deps"

		true  # Continue building even if dependencies failed
	else
		unless exists? cmd = (cmd = (recipe = getRecipe target)["configure-cmd"]) ? toString(cmd) : "configure"
			#  Nothing to be done here
			true
		else
			unless
				unless noBuildDir = recipe["no-build-dir"] or exists? dir = buildDir(target) or
					begin
						logHeader "Creating build directory"
						action "mkdir " + dir
					end
				then
					false
				else
					logHeader "Configuring"
					Dir.chdir dir unless noBuildDir
					action "rm config.cache" if exists? "config.cache"

					name = shortName target
					action((cmdLine = recipe["configure"]) ? toString(cmdLine) :
						((vars = recipe["configure-vars"]) ? toString(vars) + " " : "") +
						File.join("..", fullName(target), cmd) +
#						(name == "man" || name == "grub" ? "" :
						((args = recipe["configure-args"]) ?
							" " + toString(args) :
							" --prefix=" + prefix(target)
						) +
						((options = recipe["configure-options"]) ? " " + toString(options) : "")
					)
				end
			then
				logFailure target
				false
			else
				true
			end
		end
	end
end

def cleanPackage target
	unless
		if exists? dir = buildDir(target)
			logHeader "Deleting build directory"
			action "rm -r " + dir
		else
			action "make clean"
		end
	then
#		logFailure target
		false
	else
		action "sync"
	end
end

def makePackage target
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless action(((vars = (recipe = getRecipe(target))["make-vars"]) ? toString(vars) + " " : "") +
		"make" +
		((options = recipe["make-options"]) ? " " + toString(options) : "") +
		((targets = recipe["make-targets"]) ? " " + toString(targets) : "")
	)
		logFailure target
		false
	else
		action "sync"
	end
end

def testPackage target
	if exists? dir = buildDir(target) then Dir.chdir dir end

	unless action "make " +
		((options = (recipe = getRecipe(target))["test-options"]) ? toString(options) + " " : "") +
		((targets = recipe["test-targets"]) ? toString(targets) : "check")
	then
		logFailure target
		false
	else
		action "sync"
	end
end

def installPackage target
	unless
		if target[-4..-1] == ".tgz" and exists? target  # A distribution package
			if exists? dir = installPath(target) and not
				begin
					logHeader "Uninstalling " + shortName(target)
					uninstallPackage target  # Double failure logging!
				end
			then
				false
			else
				action "tar -C /usr -xpzf " + target and
				begin
					logHeader "Registering " + target
					action "pkgmanager -a " + dir
				end
			end
		else
			Dir.chdir target

			unless thirdParty?
				if exists? dir = buildDir(target) then Dir.chdir dir end
				action "make install"
			else
				if exists? root = installPath(target) and not
					begin
						logHeader "Uninstalling " + shortName(target)
						uninstallPackage target  # Double failure logging!
					end
				then
					false
				else
					if dirs = (recipe = getRecipe target)["install-tree"]
						logHeader "Creating subdirectories"
						logDetail root
						Dir.mkdir root

						for dir in toList dirs
							logDetail d = File.join(root, dir)
							Dir.mkdir d
						end
					end

					if exists? dir = buildDir(target) then Dir.chdir dir end

					if not action((cmdLine = (recipe = getRecipe target)["install"]) ? toString(cmdLine) :
						"make" +
						(	(arg = recipe["install-prefix"]) ? " " + arg + root :
							@systemBuild ? " prefix=" + root :
							""
						) +
						" install"
#						" install-strip"
					)
						false
					elsif files = recipe["documentation"] and not
						begin
							logHeader "Installing documentation"
							Dir.chdir @workDir
							Dir.chdir target
							action "cp -a #{toString files} " + root
						end
					then
						false
					elsif exists? filesPath = File.join(@packagesPath, fullName(target), "distro") and not
						begin
							logHeader "Installing extra files"
							action "cp -a #{File.join filesPath, "*"} " + root
						end
					then
						false
					else
						@systemBuild or
						begin
							logHeader "Registering " + target
							action "pkgmanager -a " + root
						end
					end
				end
			end
		end
	then
		logFailure target
	else
		action "sync"
	end
end

def uninstallPackage target
	unless
		if dir? target and not
			begin
				Dir.chdir target
				thirdParty?
			end
		then  # A native module
			if exists? dir = buildDir(target) then Dir.chdir dir end
			action "make uninstall"
		else
			dir = installPath target
			name = shortName target

			unless @systemBuild or
				begin
					logHeader "Unregistering " + name
					action "pkgmanager -r " + dir
				end
			then
				false
			else
				logHeader "Deleting " + name
				action "rm -r " + dir
			end
		end
	then
		logFailure target
		false
	else
		action "sync"
	end
end

def makeDistroPackage target  # Should only be called if it's a system build
	if thirdParty?
		installPackage target
	else
		if exists? dir = buildDir(target) then Dir.chdir dir end

		unless
			unless action "make dist"
				false
			else
#				logHeader "Installing documentation"
#				if action "make doc"
#					action "make install-doc"
#				end

				true
			end
		then
			logFailure target
		else
			action "sync"
		end
	end
end

def buildPackage target
	if getPackage target  # Source is available
		Dir.chdir @workDir  # Target path may be relative or absolute
		Dir.chdir target

		logHeader "Cleaning"
		cleanPackage target

		if configurePackage target  # No failed configuration
			# Build the directory
			logHeader "Making"
			makePackage target
		end
	end

	Dir.chdir @workDir
end


# Functions for multiple packages

def doPackages command, target
	# Visit all directories

	for package in getProfile target
		logEntry package

		Dir.chdir package
		action command
		Dir.chdir @workDir
	end
end

def prepare
	if @systemBuild
		logHeader "Building distribution tree"

		if exists? @distroRoot
			action "rm -r " + File.join(@distroRoot, "*")
		else
			Dir.mkdir @distroRoot
		end
		Dir.chdir @distroRoot

#		action File.join(@buildTools, "mkbase.sh") + " " + @distroRoot
		for dir in load File.join(@builderPath, "distro-tree")
			logDetail dir
			Dir.mkdir dir unless exists? dir
		end

		Dir.chdir @workDir
		action "sync"
	end
end

def patch target
	logHeader "Patching " + target

	# Patch all directories

	for package in getProfile target
		logEntry package

		Dir.chdir package
		unless patchPackage package
			logError "Source not patched"
			logFailure target
		end
		Dir.chdir @workDir
	end
end

def get target
	logHeader "Fetching " + target

	# Fetch all directories

	for package in getProfile target
		logEntry package
		getPackage package
	end
end

def distclean target
	logHeader "Cleaning distribution " + target
	doPackages "make distclean", target
end

def configure target
	logHeader "Configuring " + target

	# Configure all directories

	for package in getProfile target
		logEntry package

		Dir.chdir package
		configurePackage package
		Dir.chdir @workDir
	end
end

def clean target
	logHeader "Cleaning " + target

	# Clean all directories

	for package in getProfile target
		logEntry package

		Dir.chdir package
		cleanPackage package
		Dir.chdir @workDir
	end
end

def make target
	logHeader "Making " + target

	# Make all directories

	for package in getProfile target
		logEntry package

		Dir.chdir package
		makePackage package
		Dir.chdir @workDir
	end
end

def test target
	logHeader "Testing " + target

	# Test all directories

	for package in getProfile target
		logEntry package

		Dir.chdir package
		testPackage package
		Dir.chdir @workDir
	end
end

def install target
	logHeader "Installing " + target

	# Install all directories or distribution packages

	for package in getProfile target
		logEntry package

		installPackage package
		Dir.chdir @workDir
	end
end

def uninstall target
	logHeader "Uninstalling " + target

	# Uninstall all directories

	for package in getProfile target
		logEntry package

		uninstallPackage package
		Dir.chdir @workDir
	end
end

def makeDistro target
	logHeader "Making distribution " + target

	profile = getProfile(target)
	if @systemBuild
		# Visit all directories

		for package in profile
			logEntry package
			Dir.chdir package
			makeDistroPackage package
			Dir.chdir @workDir
		end
	else  # Create a single package
		file = (name = fullName target) + ".bin.1"

		if  # Tar it up
			if action "tar cvf #{file}.tar" +
				" -C #{@installRoot} " +
				(profile.collect {|package| installName package}).join(" ") +
				(files = getRecipe(target)["distro-files"] ? " " + files : "")
			then
				if profile.is_a? Array and exists? distroDir = File.join(@packagesPath, name, "distro")
					# It's a compound package; add extra files
					Dir.chdir distroDir
					action "tar rvf #{File.join @workDir, file}.tar *"
					Dir.chdir @workDir
				else
					true
				end
			end
		then
			# Zip it up
			if action "gzip #{file}.tar"
				action "mv #{file}.tar.gz #{file}.tgz"
			end
		end
	end
end

def build target
	logHeader "Building " + target

	# Build all directories

	for package in getProfile target
		logEntry package
		buildPackage package
	end
end


# Helper functions

def deleteCVSData
	# Delete all CVS dirs
	# (They would trigger some packages to reconfigure themselves.)

	logHeader "Cleaning out CVS dirs"

	Dir["**/CVS"].each do |dir|
		logDetail dir

		# Delete all files in the CVS dir first
		Dir.foreach dir do |file|
			f = File.join dir, file
			File.delete f if File.stat(f).file?
		end

		Dir.delete dir
	end

	logHeader "Cleaning out .cvsignore files"

	Dir["**/.cvsignore"].each do |file|
		logDetail file
		File.delete file
	end
end

def exists? file
	FileTest.exists? file
end

def dir? file
	FileTest.directory? file
end

def load file  # Load the lines of a file into an array, discarding comments and empty lines
	lines = []

	File.open file do |file|
		file.each do |line|
			# Get rid of record delimiter, comments and empty lines
			lines += [line.chomp] unless line.chomp == "" or line[0, 1] == ";"
		end
	end

	lines
end

def save data, file  # Write an array to a text file
	File.open file, "w" do |file|
		for line in data
			file << line + "\n"
		end
	end
end

def toHash text  # Load key/value pairs into a hash table
	hash = {}

	for line in text
		if line !~ /^\s+/  # A key line
			unless i = line.index(/\s/)  # A single key
				hash[lastKey = line] = ""
			else  # A key with a single value
				hash[line[0, i]] = line[i + 1 .. line.length - 1].strip
			end
		else  # Starts with whitespace, so it's a list value
			if hash[lastKey] == ""
				hash[lastKey] = [line.strip]
#				margin = $&
			else
				hash[lastKey] << line.strip
			end
		end
	end

	hash
end

def toList value  # Normalize value into an array
	if value.is_a? String
		if value == ""
			[]
		else
			[value]
		end
	else  # Assume it's already an array, or nil
		value
	end
end

def toString value  # Join list value into a space-separated string
	if value.is_a? Array
		value.join(" ")
	else  # Assume it's already a string, or nil
		value
	end
end

def thirdParty?
	exists? ((cmd = getRecipe(dir = Dir.getwd)["configure-cmd"]) ? toString(cmd) : "configure") or
		shortName(dir) == "bzip2"
# Currently conflicts with Ffmpeg:
#		exists? File.join(@packagesPath, package = fullName(Dir.getwd), package + ".recipe")
end

def fullName package
	# Extract name including version, if necessary
	File.basename package[-1, 1] == "/" ? package.chop : package
end

def shortName package
	# Extract name without version
	/(-\d)|$/.match(fullName(package)).pre_match
end

def installName package
	package = fullName package
	@includeVersion && ! @systemBuild ?
		package :
		shortName(package)
end

def prefix package
	File.join "/usr", installName(package)
end

def installPath package
	File.join @installRoot, installName(package)
end

def recipePath package
	File.join @packagesPath, fullName(package)
end

def patchesPath package
	File.join recipePath(package), "patches"
end

def buildDir package
	"../=" + fullName(package)
end

def getProfile target  # Return the list of packages for the build target
	if target["/"]  # A single directory
		target[-1, 1] == "/" ? target.chop : target
	elsif exists? file = File.join(@profilesPath, target)  # A profile
		load file
	else
		target
	end
end

def loadRecipe package  # Read a recipe file
	if exists? file = File.join(recipePath(package = fullName(package)), package + ".recipe")
		load file
	else
		[]
	end
end

def getRecipe package  # Load the key/value pairs of a recipe into a hash table
	toHash loadRecipe package
end

def action command  # Return the output of the shell command, or false if unsuccessful
	logAction command
	stdout = `#{command}`
	if (status = $? >> 8) == 0  # OK
		logResult stdout
		stdout
	else
		logError status
		logResult stdout
		false
	end
end

def openLogs
	@failures = []

	Dir.mkdir @logsPath unless exists? @logsPath

	@log		= File.new File.join(@logsPath, "last-stdout"), "w"
	@summary	= File.new File.join(@logsPath, "last-summary"), "w"
	@failLog	= File.new File.join(@logsPath, "last-failures"), "w"

	@log		<< s = "Building in root directory #{@workDir}\n"
	@summary	<< s
	@failLog	<< s
end

def closeLogs
	@log		<< s = "\nFinished\n"
	@summary	<< s

	@log.close
	@summary.close
	@failLog.close
end

def logHeader header
	print		"\n" + s = header + "\n"
	@log		<< "\n#{s}\n"
	@summary	<< s
end

def logSubheader header
	print		"\n" + s = header + "\n"
	@log		<< "\n" + s
	@summary	<< s
end

def logEntry entry
	print		s = "\n#{entry}\n"
	@log		<< s
	@summary	<< s
end

def logDetail detail
	puts		detail
	@log		<< detail + "\n"
end

def logAction action
	puts		"\n#{action}\n"
	@log		<< action + ": "
	@summary	<< action
end

def logError error
	puts		"\n" + s = "Error: #{error}"
	@log		<< s + ":"
	@summary	<< ": " + s
end

def logResult result
	@log		<< "\n\n" << result
	@summary	<< "\n"
end

def logFailure target
	@failLog	<< target + "\n"
	@failures	<< target
end


# Main function

arg1, arg2 = ARGV[0], ARGV[1]

case arg1
when "-v", "--version"
	puts "Syllable Build System 0.4.4",
		"Copyright (c) 2002-2004 Kaj de Vos",
		"License: GPL 2"
when "?", "-?", "-h", "-help", "--help"
	puts "Usage: build [<command>] [<package> | <profile> | <distribution> | <log>]",
		"<command>:",
		"  -h, --help,   Show this help information",
		"    -help, ?, -?",
		"  -v, --version Show version information",
		"  scrub         Delete CVS control files recursively from the current directory",
		"  prepare       Initialize system distribution tree",
		"  get           Fetch and patch sources",
		"  patch         Patch sources",
		"  distclean",
		"  clean",
		"  configure",
		"  make",
		"  test",
		"  install       (Run as super-user)",
		"  uninstall     (Run as super-user)",
		"  distro        Build a distribution package or a system distribution",
		"  profile       List a profile",
		"  recipe        List a recipe",
		"  log           Show the last log",
		"<package>:      Package subdirectory",
		"<profile>:      Profile name",
		"  last          Last used profile",
		"  failures      Profile for last failures",
		"<distribution>: Distribution package ((un)install command only)",
		"<log>:          Log name",
		"  summary       Summarized log",
		"  failures      Log of failed packages"
when "profile"	then puts getProfile arg2
when "recipe"	then puts loadRecipe arg2
when "log"		then print IO.readlines(File.join(@logsPath, arg2 ? "last-" + arg2 : "last-stdout"))
else
	openLogs

	if arg1 == "scrub"
		deleteCVSData
	elsif arg1 == "prepare"
		prepare
	else
		profile = getProfile target = arg2 ? arg2 : arg1 ? arg1 : "default"

		if profile.is_a? Array  # Not a single package
			save profile, File.join(@profilesPath, "last")
		end

		if @systemBuild
			File.delete "/ainc" if exists? "/ainc"
			action "ln -s #{File.join @workDir, "sys/include"} /ainc"

			prepare unless exists? @distroRoot
		end

		case arg1
		when "get"			then get arg2
		when "patch"		then patch arg2
		when "distclean"	then distclean arg2
		when "clean"		then clean arg2
		when "configure"	then configure arg2
		when "make"			then make arg2
		when "test"			then test arg2
		when "install"		then install arg2
		when "uninstall"	then uninstall arg2
		when "distro"		then makeDistro arg2
		else
			if arg2
				logError "Unrecognized command"
				exit
			else
				build target
			end
		end

		if profile.is_a? Array  # Not a single package
			save @failures, File.join(@profilesPath, "failures")
		end

		if @systemBuild
			File.delete "/ainc"
			action "ln -s /system/include /ainc"
		end

		action "sync"
	end

	closeLogs
end
