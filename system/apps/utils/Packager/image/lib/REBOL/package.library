ORCA [
	Title:		"Package installation library"
	Version:	0.3.1
	Author:		"Kaj de Vos"
	Rights: {
		Copyright (c) 2006,2007 Kaj de Vos
		License: LGPL
	}
	Purpose:	"Registers and unregisters (binary) packages by managing pools of symbolic links."
	Example:	"do %/atheos/autolnk/lib/REBOL/package.library"

	Tabs:		4
]

log: context [  ; Singleton logger object
	open: func [] [
	]
	close: does [
	]

	header: func [header] [
		prin newline
		print header
	]
	detail: func [detail] [
;		print detail
	]
	action: func [action] [
;		prin newline
;		print action
;		prin newline
	]
	output: func [output] [
	]
	error: func [error] [
		prin newline
		print ["Error:" error]
	]
	warning: func [warning] [
		prin newline
		print ["Warning:" warning]
	]
	failure: func [module] [
		prin newline
		print ["Package" module "failed!"]
	]
]

action: func ["Returns the output of a shell command, or false if unsuccessful."
	command "Shell command."
	/local status stdout
][
	log/action command

	either (status: call/wait/output command stdout: "") = 0 [
;		FIXME: ORCA call/output bug:
		log/output stdout
		stdout
	][
		log/error status
		log/output stdout
		no
	]
]

build: context [
	system?: no
]

stage-proto: context [
;	type: none
;	root: %/
;	packages-root: %/usr/
	indexes: %/atheos/autolnk
	
	new: func ["Returns a new stage object; of the running system by default."
		stage' [file! string! none!]
	][
		make self [indexes: to-file any [stage' indexes]]
	]

	index-node: func [package node
		/local source target
	][
;		source: join packages-root [package "/" node]
		source: join package ["/" node]
		target: join indexes ["/" node]

		either dir? source [
			either exists? target [
;				TODO: detect a symlink:
;				if link? target [log/warning join "directory " [target " is a link"]]
				yes
			][
				if dir? target [log/warning join "replacing broken directory link " target]
				action join "mkdir " target
			]
		][
			either node = "info/dir" and exists? target [
				log/warning "info/dir file not registered due to pre-existing file"
				yes
			][
				either exists? target [
					log/warning join "conflict: replacing " [target "!"]
				][
;					TODO: detect a symlink:
;					if file? target [log/warning join "replacing broken link " target]
				]
				action join "ln -sf " [source " " target]
			]
		]
	]
	
	remove-node: func [subdir node
		/local index file
	][
		index: join indexes ["/"  file: join subdir ["/" node]]

		either dir? index [
			any [
;				FIXME: bug in ORCA list comparison:
;				(read index) <> []  ; Indexes directory not empty?
				(length? read index) > 0  ; Indexes directory not empty?
;				action join "rmdir " index
				; May be a symlink from old package manager:
				action join "rm -r " index
			]
		][
;			FIXME: ORCA join bug:
;			change-dir join indexes ["/" subdir]
;			TODO: detect a symlink:
;			either file? node [
			either exists? index [
				either file = "info/dir" [
					log/warning "info/dir file left untouched"
					yes
				][
					action join "rm " index
				]
			][
				log/warning join "link " [index " did not exist"]
				yes
			]
		]
	]
]

system-image: stage-proto/new none

package-proto: context [
	package: stage: none

	flat-dirs:	 [etc bin sbin info early-init init]
	nested-dirs: [lib libexec include share man]

	new: func ["Returns a new package object."
		package' [file! string!]
		stage' [object! none!]
	][
		make self [
			package: to-file package'
			stage: any [stage' system-image]
		]
	]

	register: func ["Indexes the package into the staging areas."
		stages [block! none!]
		/local path
	][
		log/header join "Registering " package

		either all [
			do-subdirs :index-subdir any [stages reduce [stage]]
			any [
				not exists? path: join package "/man"
				(
					log/header "Generating manual pages"
					action join "manmanager -a " path
				)
			]
		][
			action "sync"
		][
			log/failure package
			no
		]
	]

	unregister: func ["Unlinks the package from the staging areas."
		stages [block! none!]
		/local path
	][
		log/header join "Unregistering " package

		either all [
			do-subdirs :remove-subdir any [stages reduce [stage]]
;			either no [  ; FIXME: manmanager fails on deleting non-existing manuals
			any [
				not exists? path: join package "/man"
				(
					log/header "Deleting manual pages"
					action join "manmanager -r " path
				)
			]
		][
			action "sync"
		][
			log/failure package
			no
		]
	]


	do-subdirs: func [task stages
		/local subdir
	][
		foreach subdir flat-dirs [
			unless task stages subdir no
				[return no]
		]
		foreach subdir nested-dirs [
			unless task stages subdir yes
				[return no]
		]
	]
	
	index-subdir: func [stages subdir nesting?
		/local dir entry node s
	][
;		either exists? dir: join stage/packages-root [package "/" subdir] [
		any [
			not exists? dir: join package ["/" subdir]
			(
				log/detail join "Processing subdirectory " subdir
				change-dir dir

				foreach entry read %. [
					node: join subdir ["/" entry]
					foreach s stages [
						unless s/index-node package node
							[return no]
					]
					if nesting? and dir? entry [
						unless index-subdir stages node yes
							[return no]
						change-dir dir
					]
				]
				yes
			)
		]
	]
	
	remove-subdir: func [stages subdir nesting?
		/local dir entry s
	][
;		either exists? dir: join stage/packages-root [package "/" subdir] [
		any [
			not exists? dir: join package ["/" subdir]
			(
				log/detail join "Processing subdirectory " subdir
				change-dir dir

				foreach entry read %. [
					if nesting? and dir? entry [
						unless remove-subdir stages  join subdir ["/" entry]  yes
							[return no]
					]
					foreach s stages [
						unless s/remove-node subdir entry
							[return no]
					]
					change-dir dir
				]
				yes
			)
		]
	]
]
