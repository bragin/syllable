ORCA [
	Title:		"Package installation library"
	Version:	0.2.0
	Author:		"Kaj de Vos"
	Rights: {
		Copyright (c) 2006 Kaj de Vos
		License: GPL 2 or any later version
	}
	Purpose:	"Registers and unregisters binary packages by managing symbolic links in the system."
	Example:	"do %/atheos/autolnk/lib/REBOL/package.library"

	Tabs:		4
]

log: context [  ; Singleton logger object
	open: func [] [
	]
	close: does [
	]

	header: func [header] [
		prin newline
		print header
	]
	detail: func [detail] [
;		print detail
	]
	action: func [action] [
;		prin newline
;		print action
;		prin newline
	]
	output: func [output] [
	]
	error: func [error] [
		prin newline
		print ["Error:" error]
	]
	warning: func [warning] [
		prin newline
		print ["Warning:" warning]
	]
	failure: func [module] [
		prin newline
		print ["Package" module "failed!"]
	]
]

action: func ["Returns the output of a shell command, or false if unsuccessful"
	command "Shell command"
	/local status stdout
][
	log/action command

	either (status: call/wait/output command stdout: "") = 0 [
;		FIXME: Orca call/output bug:
		log/output stdout
		stdout
	][
		log/error status
		log/output stdout
		no
	]
]

build: context [
	system?: no
]

stage-proto: context [
;	packages-root: indexes: none
	indexes: %/atheos/autolnk/
	
	index-node: func [package node
		/local source destination
	][
;		source: join packages-root [package "/" node]
		source: join package ["/" node]
		destination: join indexes node

		either dir? source [
			either exists? destination [
;				if link? destination [log/warning join "directory " [destination " is a link"]]
				yes
			][
				if dir? destination [log/warning join "replacing broken directory link " destination]
				action join "mkdir " destination
			]
		][
			either node = "info/dir" and exists? destination [
				log/warning "info/dir file not registered due to pre-existing file"
				yes
			][
				either exists? destination [
					log/warning join "conflict: replacing " [destination "!"]
				][
;					FIXME: Bug in Orca when path given:
;					if file? destination [log/warning join "replacing broken link " destination]
				]
				action join "ln -sf " [source " " destination]
			]
		]
	]
	
	remove-node: func [subdir node
		/local index file
	][
		index: join indexes [file: join subdir ["/" node]]

		either dir? index [
			any [
;				FIXME: Bug in Orca list comparison:
;				(read index) <> []  ; Indexes directory not empty?
;				Remove non-empty dirs as well for now; they could be from the old package manager:
;				(length? read index) > 0  ; Indexes directory not empty?
;				action join "rmdir " index
				; May be a symlink from old package manager:
				action join "rm -r " index
			]
		][
;			FIXME: Orca join bug:
;			change-dir join indexes [subdir]
;			FIXME: Orca file? bug:
;			either file? node [
			either exists? index [
				either file = "info/dir" [
					log/warning "info/dir file left untouched"
					yes
				][
					action join "rm " index
				]
			][
				log/warning join "link " [index " did not exist"]
				yes
			]
		]
	]
]

system-image: make stage-proto [
	type: none
	root: %/
	packages-root: %/usr/
	indexes: %/atheos/autolnk/
]

stage: make stage-proto [
	type: none
	root: none
]

package-proto: context [
	package: stage: none

	flat-dirs:	 [etc bin sbin info early-init init]
	nested-dirs: [lib libexec include share man]

	new: func [package' stage'] [
		make self [package: to-file package' stage: stage']
	]

	register: func [stage
		/local path
	][
		log/header join "Registering " package

		either all [
			do-subdirs :index-subdir reduce [system-image]
			either exists? path: join package "/man" [
				log/header "Generating manual pages"
				action join "manmanager -a " path
			][yes]
		][
			action "sync"
		][
			log/failure package
			no
		]
	]

	unregister: func [stage
		/local path
	][
		log/header join "Unregistering " package

		either all [
			do-subdirs :remove-subdir reduce [system-image]
;			either no [  ; FIXME: manmanager fails on deleting non-existing manuals
			either exists? path: join package "/man" [
				log/header "Deleting manual pages"
				action join "manmanager -r " path
			][yes]
		][
			action "sync"
		][
			log/failure package
			no
		]
	]


	do-subdirs: func [task stages
		/local subdir
	][
		foreach subdir flat-dirs [
			unless task stages subdir no
				[return no]
		]
		foreach subdir nested-dirs [
			unless task stages subdir yes
				[return no]
		]
	]
	
	index-subdir: func [stages subdir nesting?
		/local dir entry node s
	][
;		either exists? dir: join stage/packages-root [package "/" subdir] [
		either exists? dir: join package ["/" subdir] [
			log/detail join "Processing subdirectory " subdir
			change-dir dir

			foreach entry read %. [
				node: join subdir ["/" entry]
				foreach s stages [
					unless s/index-node package node
						[return no]
				]
				if nesting? and dir? entry [
					unless index-subdir stages node yes
						[return no]
					change-dir dir
				]
			]
			yes
		][yes]
	]
	
	remove-subdir: func [stages subdir nesting?
		/local dir entry s
	][
;		either exists? dir: join stage/packages-root [package "/" subdir] [
		either exists? dir: join package ["/" subdir] [
			log/detail join "Processing subdirectory " subdir
			change-dir dir

			foreach entry read %. [
				if nesting? and dir? entry [
					unless remove-subdir stages join subdir ["/" entry] yes
						[return no]
				]
				foreach s stages [
					unless s/remove-node subdir entry
						[return no]
				]
				change-dir dir
			]
			yes
		][yes]
	]
]

